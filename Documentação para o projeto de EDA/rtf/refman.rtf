{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\info 
{\title {\comment Documenta\'E7\'E3o para o projeto de EDA  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
2.0 \par
}}Documenta\'E7\'E3o para o projeto de EDA}
{\comment Gerado por doxygen 1.9.7.}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt Documenta\'E7\'E3o para o projeto de EDA}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Vers\'E3o 2.0\par\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \'CDndice\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\par \pard\plain 
\par \pard\plain 
\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
EDA-Project\par \pard\plain 
{\tc\tcl1 \v EDA-Project}
{\xe \v EDA-Project}
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Projeto para a Unidade Curricular de Estruturas de Dados Avan\'E7adas.\par
}
 \par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Compila\'E7\'E3o
\par}
{\tc\tcl2 \v Compila\'E7\'E3o}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Para compilar o projeto, execute o seguinte comando no terminal:\par
mingw32-make.exe\par
}
 \par}
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Execu\'E7\'E3o
\par}
{\tc\tcl2 \v Execu\'E7\'E3o}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Ap\'F3s a compila\'E7\'E3o bem-sucedida, execute o programa com um dos seguintes comandos:\par
./projectEDA.exe\par
ou\par
mingw32-make.exe; ./projectEDA.exe\par
}
 \par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\'CDndice dos componentes\par \pard\plain 
{\tc \v \'CDndice dos componentes}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Lista de componentes\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Lista de classes, estruturas, uni\'F5es e interfaces com uma breve descri\'E7\'E3o:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b Adjacency} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ED} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Graph} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Path} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Queue} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b QueueNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAED \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Vertex} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\'CDndice dos ficheiros\par \pard\plain 
{\tc \v \'CDndice dos ficheiros}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Lista de ficheiros\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Lista de todos os ficheiros com uma breve descri\'E7\'E3o:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b C:/Users/carlo/Desktop/EDA-Project/{\b aerial.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/carlo/Desktop/EDA-Project/{\b aerial.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/carlo/Desktop/EDA-Project/{\b fileUtils.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/carlo/Desktop/EDA-Project/{\b fileUtils.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/carlo/Desktop/EDA-Project/{\b graph.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/carlo/Desktop/EDA-Project/{\b graph.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/carlo/Desktop/EDA-Project/{\b graphIO.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/carlo/Desktop/EDA-Project/{\b graphOp.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/carlo/Desktop/EDA-Project/{\b graphSearch.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/carlo/Desktop/EDA-Project/{\b gridUtils.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/carlo/Desktop/EDA-Project/{\b gridUtils.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/carlo/Desktop/EDA-Project/{\b interference.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/carlo/Desktop/EDA-Project/{\b interference.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/carlo/Desktop/EDA-Project/{\b main.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Documenta\'E7\'E3o da classe{\tc \v Documenta\'E7\'E3o da classe}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia \'E0 estrutura Adjacency\par \pard\plain 
{\tc\tcl2 \v Adjacency}
{\xe \v Adjacency}
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
\par
{
{\f2 #include <graph.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b distance}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b resonanceFrequency}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b destinationVertexIndex}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Adjacency} * {\b next}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos dados membro\par
\pard\plain 
{\xe \v destinationVertexIndex\:Adjacency}
{\xe \v Adjacency\:destinationVertexIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Adjacency::destinationVertexIndex}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v distance\:Adjacency}
{\xe \v Adjacency\:distance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Adjacency::distance}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v next\:Adjacency}
{\xe \v Adjacency\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b Adjacency}* Adjacency::next}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v resonanceFrequency\:Adjacency}
{\xe \v Adjacency\:resonanceFrequency}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char Adjacency::resonanceFrequency}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para esta estrutura foi gerada a partir do seguinte ficheiro:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/carlo/Desktop/EDA-Project/{\b graph.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia \'E0 estrutura ED\par \pard\plain 
{\tc\tcl2 \v ED}
{\xe \v ED}
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
\par
{
{\f2 #include <aerial.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b resonanceFrequency}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b coordinateX}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b coordinateY}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ED} * {\b next}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos dados membro\par
\pard\plain 
{\xe \v coordinateX\:ED}
{\xe \v ED\:coordinateX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ED::coordinateX}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v coordinateY\:ED}
{\xe \v ED\:coordinateY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ED::coordinateY}}
\par
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v next\:ED}
{\xe \v ED\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b ED}* ED::next}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v resonanceFrequency\:ED}
{\xe \v ED\:resonanceFrequency}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char ED::resonanceFrequency}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para esta estrutura foi gerada a partir do seguinte ficheiro:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/carlo/Desktop/EDA-Project/{\b aerial.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia \'E0 estrutura Graph\par \pard\plain 
{\tc\tcl2 \v Graph}
{\xe \v Graph}
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
\par
{
{\f2 #include <graph.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b numVertices}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Vertex} * {\b head}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos dados membro\par
\pard\plain 
{\xe \v head\:Graph}
{\xe \v Graph\:head}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Vertex}* Graph::head}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v numVertices\:Graph}
{\xe \v Graph\:numVertices}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Graph::numVertices}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para esta estrutura foi gerada a partir do seguinte ficheiro:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/carlo/Desktop/EDA-Project/{\b graph.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia \'E0 estrutura Path\par \pard\plain 
{\tc\tcl2 \v Path}
{\xe \v Path}
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
\par
{
{\f2 #include <graph.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Vertex} * {\b start}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Vertex} * {\b end}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b processed}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos dados membro\par
\pard\plain 
{\xe \v end\:Path}
{\xe \v Path\:end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Vertex}* Path::end}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v processed\:Path}
{\xe \v Path\:processed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Path::processed}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v start\:Path}
{\xe \v Path\:start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Vertex}* Path::start}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para esta estrutura foi gerada a partir do seguinte ficheiro:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/carlo/Desktop/EDA-Project/{\b graph.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia \'E0 estrutura Queue\par \pard\plain 
{\tc\tcl2 \v Queue}
{\xe \v Queue}
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
\par
{
{\f2 #include <graph.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QueueNode} * {\b front}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b QueueNode} * {\b rear}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos dados membro\par
\pard\plain 
{\xe \v front\:Queue}
{\xe \v Queue\:front}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QueueNode}* Queue::front}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rear\:Queue}
{\xe \v Queue\:rear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b QueueNode} * Queue::rear}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para esta estrutura foi gerada a partir do seguinte ficheiro:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/carlo/Desktop/EDA-Project/{\b graph.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia \'E0 estrutura QueueNode\par \pard\plain 
{\tc\tcl2 \v QueueNode}
{\xe \v QueueNode}
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
\par
{
{\f2 #include <graph.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b index}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b QueueNode} * {\b next}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos dados membro\par
\pard\plain 
{\xe \v index\:QueueNode}
{\xe \v QueueNode\:index}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int QueueNode::index}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v next\:QueueNode}
{\xe \v QueueNode\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b QueueNode}* QueueNode::next}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para esta estrutura foi gerada a partir do seguinte ficheiro:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/carlo/Desktop/EDA-Project/{\b graph.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia \'E0 estrutura Vertex\par \pard\plain 
{\tc\tcl2 \v Vertex}
{\xe \v Vertex}
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
\par
{
{\f2 #include <graph.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b resonanceFrequency}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b coordinateX}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b coordinateY}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Vertex} * {\b next}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Adjacency} * {\b adjacencies}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos dados membro\par
\pard\plain 
{\xe \v adjacencies\:Vertex}
{\xe \v Vertex\:adjacencies}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b Adjacency}* Vertex::adjacencies}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v coordinateX\:Vertex}
{\xe \v Vertex\:coordinateX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Vertex::coordinateX}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v coordinateY\:Vertex}
{\xe \v Vertex\:coordinateY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Vertex::coordinateY}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v next\:Vertex}
{\xe \v Vertex\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b Vertex}* Vertex::next}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v resonanceFrequency\:Vertex}
{\xe \v Vertex\:resonanceFrequency}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char Vertex::resonanceFrequency}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para esta estrutura foi gerada a partir do seguinte ficheiro:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/carlo/Desktop/EDA-Project/{\b graph.h}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Documenta\'E7\'E3o do ficheiro{\tc \v Documenta\'E7\'E3o do ficheiro}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia ao ficheiro C:/Users/carlo/Desktop/EDA-Project/aerial.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/carlo/Desktop/EDA-Project/aerial.c}
{\xe \v C:/Users/carlo/Desktop/EDA-Project/aerial.c}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdlib.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include "aerial.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ED} * {\b insertAerialEnd} ({\b ED} *list, char resonanceFrequencyTmp, int coordinateXTmp, int coordinateYTmp)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ED} * {\b removeAerial} ({\b ED} *list, int coordinateX, int coordinateY)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ED} * {\b findAerial} ({\b ED} *list, int coordinateX, int coordinateY)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v findAerial\:aerial.c}
{\xe \v aerial.c\:findAerial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ED} * findAerial ({\b ED} *  {\i list}, int  {\i coordinateX}, int  {\i coordinateY})}}
\par
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 82 \{\par
83     ED *current = list;\par
84     {\cf19 while} (current != NULL)\par
85     \{\par
86         {\cf19 if} (current->coordinateX == coordinateX && current->coordinateY == coordinateY)\par
87         \{\par
88             {\cf19 return} current;\par
89         \}\par
90         current = current->next;\par
91     \}\par
92     {\cf19 return} NULL;\par
93 \}\par
}
}
{\xe \v insertAerialEnd\:aerial.c}
{\xe \v aerial.c\:insertAerialEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ED} * insertAerialEnd ({\b ED} *  {\i list}, char  {\i resonanceFrequencyTmp}, int  {\i coordinateXTmp}, int  {\i coordinateYTmp})}}
\par
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13 \{\par
14     ED *aux, *{\cf17 new} = malloc({\cf17 sizeof}(ED));\par
15     {\cf19 if} ({\cf17 new} == NULL)\par
16     \{\par
17         printf({\cf22 "Erro ao alocar mem\'F3ria para a nova antena\\n"});\par
18         {\cf19 return} list;\par
19     \}\par
20 \par
21     {\cf17 new}->resonanceFrequency = resonanceFrequencyTmp;\par
22     {\cf17 new}->coordinateX = coordinateXTmp;\par
23     {\cf17 new}->coordinateY = coordinateYTmp;\par
24     {\cf17 new}->next = NULL;\par
25 \par
26     {\cf19 if} (list == NULL)\par
27     \{\par
28         {\cf19 return} {\cf17 new};\par
29     \}\par
30     {\cf19 else}\par
31     \{\par
32         aux = list;\par
33         {\cf19 while} (aux->next)\par
34         \{\par
35             aux = aux->next;\par
36         \}\par
37         aux->next = {\cf17 new};\par
38         {\cf19 return} list;\par
39     \}\par
40 \}\par
}
}
{\xe \v removeAerial\:aerial.c}
{\xe \v aerial.c\:removeAerial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ED} * removeAerial ({\b ED} *  {\i list}, int  {\i coordinateX}, int  {\i coordinateY})}}
\par
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 44 \{\par
45     {\cf19 if} (list == NULL)\par
46     \{\par
47         printf({\cf22 "Lista de antenas vazia. Nada para remover.\\n"});\par
48         {\cf19 return} NULL;\par
49     \}\par
50 \par
51     ED *current = list;\par
52     ED *previous = NULL;\par
53 \par
54     {\cf19 while} (current != NULL)\par
55     \{\par
56         {\cf19 if} (current->coordinateX == coordinateX && current->coordinateY == coordinateY)\par
57         \{\par
58             {\cf19 if} (previous == NULL)\par
59             \{\par
60                 list = current->next;\par
61             \}\par
62             {\cf19 else}\par
63             \{\par
64                 previous->next = current->next;\par
65             \}\par
66 \par
67             free(current);\par
68             printf({\cf22 "Antena na posi\'E7\'E3o (%d, %d) removida com sucesso.\\n"}, coordinateX, coordinateY);\par
69             {\cf19 return} list;\par
70         \}\par
71 \par
72         previous = current;\par
73         current = current->next;\par
74     \}\par
75 \par
76     printf({\cf22 "Antena na posi\'E7\'E3o (%d, %d) n\'E3o encontrada.\\n"}, coordinateX, coordinateY);\par
77     {\cf19 return} list;\par
78 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia ao ficheiro C:/Users/carlo/Desktop/EDA-Project/aerial.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/carlo/Desktop/EDA-Project/aerial.h}
{\xe \v C:/Users/carlo/Desktop/EDA-Project/aerial.h}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Componentes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ED}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_LINE_LENGTH}\~ 1000\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es de tipos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b ED} {\b ED}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ED} * {\b insertAerialEnd} ({\b ED} *list, char resonanceFrequencyTmp, int coordinateXTmp, int coordinateYTmp)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ED} * {\b removeAerial} ({\b ED} *list, int coordinateX, int coordinateY)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ED} * {\b findAerial} ({\b ED} *list, int coordinateX, int coordinateY)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das macros\par
\pard\plain 
{\xe \v MAX_LINE_LENGTH\:aerial.h}
{\xe \v aerial.h\:MAX_LINE_LENGTH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_LINE_LENGTH\~ 1000}}
\par
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos tipos\par
\pard\plain 
{\xe \v ED\:aerial.h}
{\xe \v aerial.h\:ED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b ED} {\b ED}}}
\par
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v findAerial\:aerial.h}
{\xe \v aerial.h\:findAerial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ED} * findAerial ({\b ED} *  {\i list}, int  {\i coordinateX}, int  {\i coordinateY})}}
\par
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 82 \{\par
83     ED *current = list;\par
84     {\cf19 while} (current != NULL)\par
85     \{\par
86         {\cf19 if} (current->coordinateX == coordinateX && current->coordinateY == coordinateY)\par
87         \{\par
88             {\cf19 return} current;\par
89         \}\par
90         current = current->next;\par
91     \}\par
92     {\cf19 return} NULL;\par
93 \}\par
}
}
{\xe \v insertAerialEnd\:aerial.h}
{\xe \v aerial.h\:insertAerialEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ED} * insertAerialEnd ({\b ED} *  {\i list}, char  {\i resonanceFrequencyTmp}, int  {\i coordinateXTmp}, int  {\i coordinateYTmp})}}
\par
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13 \{\par
14     ED *aux, *{\cf17 new} = malloc({\cf17 sizeof}(ED));\par
15     {\cf19 if} ({\cf17 new} == NULL)\par
16     \{\par
17         printf({\cf22 "Erro ao alocar mem\'F3ria para a nova antena\\n"});\par
18         {\cf19 return} list;\par
19     \}\par
20 \par
21     {\cf17 new}->resonanceFrequency = resonanceFrequencyTmp;\par
22     {\cf17 new}->coordinateX = coordinateXTmp;\par
23     {\cf17 new}->coordinateY = coordinateYTmp;\par
24     {\cf17 new}->next = NULL;\par
25 \par
26     {\cf19 if} (list == NULL)\par
27     \{\par
28         {\cf19 return} {\cf17 new};\par
29     \}\par
30     {\cf19 else}\par
31     \{\par
32         aux = list;\par
33         {\cf19 while} (aux->next)\par
34         \{\par
35             aux = aux->next;\par
36         \}\par
37         aux->next = {\cf17 new};\par
38         {\cf19 return} list;\par
39     \}\par
40 \}\par
}
}
{\xe \v removeAerial\:aerial.h}
{\xe \v aerial.h\:removeAerial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ED} * removeAerial ({\b ED} *  {\i list}, int  {\i coordinateX}, int  {\i coordinateY})}}
\par
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 44 \{\par
45     {\cf19 if} (list == NULL)\par
46     \{\par
47         printf({\cf22 "Lista de antenas vazia. Nada para remover.\\n"});\par
48         {\cf19 return} NULL;\par
49     \}\par
50 \par
51     ED *current = list;\par
52     ED *previous = NULL;\par
53 \par
54     {\cf19 while} (current != NULL)\par
55     \{\par
56         {\cf19 if} (current->coordinateX == coordinateX && current->coordinateY == coordinateY)\par
57         \{\par
58             {\cf19 if} (previous == NULL)\par
59             \{\par
60                 list = current->next;\par
61             \}\par
62             {\cf19 else}\par
63             \{\par
64                 previous->next = current->next;\par
65             \}\par
66 \par
67             free(current);\par
68             printf({\cf22 "Antena na posi\'E7\'E3o (%d, %d) removida com sucesso.\\n"}, coordinateX, coordinateY);\par
69             {\cf19 return} list;\par
70         \}\par
71 \par
72         previous = current;\par
73         current = current->next;\par
74     \}\par
75 \par
76     printf({\cf22 "Antena na posi\'E7\'E3o (%d, %d) n\'E3o encontrada.\\n"}, coordinateX, coordinateY);\par
77     {\cf19 return} list;\par
78 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
aerial.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/carlo/Desktop/EDA-Project/aerial.h}
{\xe \v C:/Users/carlo/Desktop/EDA-Project/aerial.h}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
Ir para a documenta\'E7\'E3o deste ficheiro.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 // File: aerial.h}\par
2 {\cf20 // Desc: Este ficheiro cont\'E9m a defini\'E7\'E3o da estrutura de dados ED e as fun\'E7\'F5es para inserir e remover antenas de uma lista ligada.}\par
3 {\cf20 // Auth: Carlos Barreiro}\par
4 {\cf20 // Mail: a20360@alunos.ipca.pt}\par
5 {\cf20 // Date: 2025/03}\par
6 \par
7 {\cf21 #ifndef AERIAL_H}\par
8 {\cf21 #define AERIAL_H}\par
9 \par
10 {\cf21 #define MAX_LINE_LENGTH 1000 }{\cf20 // Constante para o tamanho m\'E1ximo da linha do ficheiro}\par
11 \par
12 {\cf20 // Estrutura de dados ED, representa as antenas}\par
13 {\cf17 typedef} {\cf17 struct }ED\par
14 \{\par
15     {\cf18 char} resonanceFrequency; {\cf20 // Frequ\'EAncia de resson\'E2ncia da antena}\par
16     {\cf18 int} coordinateX;         {\cf20 // Coordenada X da antena}\par
17     {\cf18 int} coordinateY;         {\cf20 // Coordenada Y da antena}\par
18     {\cf17 struct }ED *next;         {\cf20 // Ponteiro para a pr\'F3xima antena na lista}\par
19 \} ED;\par
20 \par
21 {\cf20 // Fun\'E7\'E3o para adicionar uma antena (fim da lista)}\par
22 ED *insertAerialEnd(ED *list, {\cf18 char} resonanceFrequencyTmp, {\cf18 int} coordinateXTmp, {\cf18 int} coordinateYTmp);\par
23 \par
24 {\cf20 // Fun\'E7\'E3o para remover uma antena da lista}\par
25 ED *removeAerial(ED *list, {\cf18 int} coordinateX, {\cf18 int} coordinateY);\par
26 \par
27 {\cf20 // Fun\'E7\'E3o para ...}\par
28 ED *findAerial(ED *list, {\cf18 int} coordinateX, {\cf18 int} coordinateY);\par
29 \par
30 {\cf21 #endif }{\cf20 // AERIAL_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia ao ficheiro C:/Users/carlo/Desktop/EDA-Project/fileUtils.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/carlo/Desktop/EDA-Project/fileUtils.c}
{\xe \v C:/Users/carlo/Desktop/EDA-Project/fileUtils.c}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include "fileUtils.h"}\par
{\f2 #include "aerial.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ED} * {\b loadAerialsFromFile} ({\b ED} *list, const char *filename)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v loadAerialsFromFile\:fileUtils.c}
{\xe \v fileUtils.c\:loadAerialsFromFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ED} * loadAerialsFromFile ({\b ED} *  {\i list}, const char *  {\i filename})}}
\par
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14 \{\par
15     {\cf18 int} y = 1;\par
16     {\cf18 char} line[MAX_LINE_LENGTH];\par
17 \par
18     FILE *file = fopen(filename, {\cf22 "r"});\par
19     {\cf19 if} (file == NULL)\par
20     \{\par
21         {\cf19 return} list;\par
22     \}\par
23 \par
24     {\cf19 while} (fgets(line, MAX_LINE_LENGTH, file) != NULL)\par
25     \{\par
26         {\cf18 int} x = 1;\par
27         {\cf19 for} ({\cf18 int} i = 0; line[i] != {\cf23 '\\0'} && line[i] != {\cf23 '\\n'}; i++)\par
28         \{\par
29             {\cf19 if} (line[i] != {\cf23 ' '} && line[i] != {\cf23 '.'})\par
30             \{\par
31                 list = insertAerialEnd(list, line[i], x, y);\par
32             \}\par
33             {\cf19 if} (line[i] != {\cf23 ' '})\par
34             \{\par
35                 x++;\par
36             \}\par
37         \}\par
38         y++;\par
39     \}\par
40 \par
41     fclose(file);\par
42     printf({\cf22 "Dados carregados do ficheiro %s com sucesso!\\n"}, filename);\par
43     {\cf19 return} list;\par
44 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia ao ficheiro C:/Users/carlo/Desktop/EDA-Project/fileUtils.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/carlo/Desktop/EDA-Project/fileUtils.h}
{\xe \v C:/Users/carlo/Desktop/EDA-Project/fileUtils.h}
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "aerial.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ED} * {\b loadAerialsFromFile} ({\b ED} *list, const char *filename)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v loadAerialsFromFile\:fileUtils.h}
{\xe \v fileUtils.h\:loadAerialsFromFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ED} * loadAerialsFromFile ({\b ED} *  {\i list}, const char *  {\i filename})}}
\par
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14 \{\par
15     {\cf18 int} y = 1;\par
16     {\cf18 char} line[MAX_LINE_LENGTH];\par
17 \par
18     FILE *file = fopen(filename, {\cf22 "r"});\par
19     {\cf19 if} (file == NULL)\par
20     \{\par
21         {\cf19 return} list;\par
22     \}\par
23 \par
24     {\cf19 while} (fgets(line, MAX_LINE_LENGTH, file) != NULL)\par
25     \{\par
26         {\cf18 int} x = 1;\par
27         {\cf19 for} ({\cf18 int} i = 0; line[i] != {\cf23 '\\0'} && line[i] != {\cf23 '\\n'}; i++)\par
28         \{\par
29             {\cf19 if} (line[i] != {\cf23 ' '} && line[i] != {\cf23 '.'})\par
30             \{\par
31                 list = insertAerialEnd(list, line[i], x, y);\par
32             \}\par
33             {\cf19 if} (line[i] != {\cf23 ' '})\par
34             \{\par
35                 x++;\par
36             \}\par
37         \}\par
38         y++;\par
39     \}\par
40 \par
41     fclose(file);\par
42     printf({\cf22 "Dados carregados do ficheiro %s com sucesso!\\n"}, filename);\par
43     {\cf19 return} list;\par
44 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
fileUtils.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/carlo/Desktop/EDA-Project/fileUtils.h}
{\xe \v C:/Users/carlo/Desktop/EDA-Project/fileUtils.h}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
Ir para a documenta\'E7\'E3o deste ficheiro.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 // File: fileUtils.h}\par
2 {\cf20 // Desc: Declara\'E7\'F5es para fun\'E7\'F5es de manipula\'E7\'E3o de ficheiros}\par
3 {\cf20 // Auth: Carlos Barreiro}\par
4 {\cf20 // Mail: a20360@alunos.ipca.pt}\par
5 {\cf20 // Date: 2025/03}\par
6 \par
7 {\cf21 #ifndef FILE_UTILS_H}\par
8 {\cf21 #define FILE_UTILS_H}\par
9 \par
10 {\cf21 #include "aerial.h"} {\cf20 // Necess\'E1rio para a defini\'E7\'E3o de ED}\par
11 \par
12 {\cf20 // Fun\'E7\'E3o para carregar as antenas de um ficheiro}\par
13 ED *loadAerialsFromFile(ED *list, {\cf17 const} {\cf18 char} *filename);\par
14 \par
15 {\cf21 #endif }{\cf20 // FILE_UTILS_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia ao ficheiro C:/Users/carlo/Desktop/EDA-Project/graph.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/carlo/Desktop/EDA-Project/graph.c}
{\xe \v C:/Users/carlo/Desktop/EDA-Project/graph.c}
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "graph.h"}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <math.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Vertex} * {\b CreateVertex} (char resonanceFrequency, float coordinateX, float coordinateY)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b AdjacencyExists} ({\b Vertex} *origin, int destinationIndex)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Adjacency} * {\b CreateAdjacency} (float distance, char resonanceFrequency, int destinationIndex)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Vertex} * {\b InsertAdjacency} ({\b Vertex} *head, {\b Adjacency} *newAdj, int originIndex, int destinationIndex, int *res)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Vertex} * {\b InsertVertex} ({\b Vertex} *newVertex, {\b Vertex} *head, int *res)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b CalculateDistance} ({\b Vertex} *a, {\b Vertex} *b)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b FreeAdjacencies} ({\b Adjacency} *adj)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b FreeGraph} ({\b Graph} *graph)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v AdjacencyExists\:graph.c}
{\xe \v graph.c\:AdjacencyExists}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool AdjacencyExists ({\b Vertex} *  {\i origin}, int  {\i destinationIndex})}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28 \{\par
29     Adjacency *adj = origin->adjacencies;\par
30     {\cf19 while} (adj)\par
31     \{\par
32         {\cf19 if} (adj->destinationVertexIndex == destinationIndex)\par
33             {\cf19 return} {\cf17 true};\par
34         adj = adj->next;\par
35     \}\par
36     {\cf19 return} {\cf17 false};\par
37 \}\par
}
}
{\xe \v CalculateDistance\:graph.c}
{\xe \v graph.c\:CalculateDistance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float CalculateDistance ({\b Vertex} *  {\i a}, {\b Vertex} *  {\i b})}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 136 \{\par
137     {\cf19 return} sqrtf(powf(a->coordinateX - b->coordinateX, 2) + powf(a->coordinateY - b->coordinateY, 2));\par
138 \}\par
}
}
{\xe \v CreateAdjacency\:graph.c}
{\xe \v graph.c\:CreateAdjacency}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Adjacency} * CreateAdjacency (float  {\i distance}, char  {\i resonanceFrequency}, int  {\i destinationIndex})}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 41 \{\par
42     Adjacency *adj = (Adjacency *)malloc({\cf17 sizeof}(Adjacency));\par
43     {\cf19 if} (adj)\par
44     \{\par
45         adj->distance = distance;\par
46         adj->resonanceFrequency = resonanceFrequency; {\cf20 // Agora \'E9 char}\par
47         adj->destinationVertexIndex = destinationIndex;\par
48         adj->next = NULL;\par
49     \}\par
50     {\cf19 return} adj;\par
51 \}\par
}
}
{\xe \v CreateVertex\:graph.c}
{\xe \v graph.c\:CreateVertex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Vertex} * CreateVertex (char  {\i resonanceFrequency}, float  {\i coordinateX}, float  {\i coordinateY})}}
\par
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13 \{\par
14     Vertex *v = (Vertex *)malloc({\cf17 sizeof}(Vertex));\par
15     {\cf19 if} (v)\par
16     \{\par
17         v->resonanceFrequency = resonanceFrequency;\par
18         v->coordinateX = coordinateX;\par
19         v->coordinateY = coordinateY;\par
20         v->adjacencies = NULL;\par
21         v->next = NULL;\par
22     \}\par
23     {\cf19 return} v;\par
24 \}\par
}
}
{\xe \v FreeAdjacencies\:graph.c}
{\xe \v graph.c\:FreeAdjacencies}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void FreeAdjacencies ({\b Adjacency} *  {\i adj})}}
\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 142 \{\par
143     {\cf19 while} (adj != NULL)\par
144     \{\par
145         Adjacency *temp = adj;\par
146         adj = adj->next;\par
147         free(temp);\par
148     \}\par
149 \}\par
}
}
{\xe \v FreeGraph\:graph.c}
{\xe \v graph.c\:FreeGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void FreeGraph ({\b Graph} *  {\i graph})}}
\par
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 153 \{\par
154     {\cf19 if} (graph == NULL)\par
155         {\cf19 return};\par
156 \par
157     Vertex *current = graph->head;\par
158     {\cf19 while} (current != NULL)\par
159     \{\par
160         Vertex *temp = current;\par
161         current = current->next;\par
162         FreeAdjacencies(temp->adjacencies); {\cf20 // Liberta adjac\'EAncias do v\'E9rtice}\par
163         free(temp);\par
164     \}\par
165     free(graph); {\cf20 // Liberta a estrutura do grafo}\par
166 \}\par
}
}
{\xe \v InsertAdjacency\:graph.c}
{\xe \v graph.c\:InsertAdjacency}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Vertex} * InsertAdjacency ({\b Vertex} *  {\i head}, {\b Adjacency} *  {\i newAdj}, int  {\i originIndex}, int  {\i destinationIndex}, int *  {\i res})}}
\par
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 55 \{\par
56     {\cf19 if} (!head || !newAdj)\par
57     \{\par
58         *res = 0;\par
59         {\cf19 return} head;\par
60     \}\par
61 \par
62     Vertex *origin = head;\par
63     {\cf19 for} ({\cf18 int} i = 0; origin && i < originIndex; i++)\par
64         origin = origin->next;\par
65     Vertex *dest = head;\par
66     {\cf19 for} ({\cf18 int} i = 0; dest && i < destinationIndex; i++)\par
67         dest = dest->next;\par
68 \par
69     {\cf19 if} (!origin || !dest)\par
70     \{\par
71         *res = 0;\par
72         {\cf19 return} head;\par
73     \}\par
74 \par
75     newAdj->next = origin->adjacencies;\par
76     origin->adjacencies = newAdj;\par
77     *res = 1;\par
78     {\cf19 return} head;\par
79 \}\par
}
}
{\xe \v InsertVertex\:graph.c}
{\xe \v graph.c\:InsertVertex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Vertex} * InsertVertex ({\b Vertex} *  {\i newVertex}, {\b Vertex} *  {\i head}, int *  {\i res})}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 83 \{\par
84     {\cf19 if} (!newVertex)\par
85     \{\par
86         *res = 0;\par
87         {\cf19 return} head;\par
88     \}\par
89 \par
90     {\cf19 if} (!head)\par
91     \{\par
92         *res = 1;\par
93         {\cf19 return} newVertex;\par
94     \}\par
95 \par
96     Vertex *last = head;\par
97     {\cf18 int} newIndex = 0;\par
98     {\cf19 while} (last->next)\par
99     \{\par
100         last = last->next;\par
101         newIndex++;\par
102     \}\par
103     last->next = newVertex;\par
104     newIndex++;\par
105 \par
106     Vertex *aux = head;\par
107     {\cf18 int} existingIndex = 0;\par
108     {\cf19 while} (aux)\par
109     \{\par
110         {\cf19 if} (aux->resonanceFrequency == newVertex->resonanceFrequency)\par
111         \{\par
112             {\cf18 float} dist = CalculateDistance(aux, newVertex);\par
113             {\cf19 if} (!AdjacencyExists(aux, newIndex))\par
114             \{\par
115                 Adjacency *a1 = CreateAdjacency(dist, newVertex->resonanceFrequency, newIndex);\par
116                 head = InsertAdjacency(head, a1, existingIndex, newIndex, res);\par
117             \}\par
118             {\cf19 if} (!AdjacencyExists(newVertex, existingIndex))\par
119             \{\par
120                 Adjacency *a2 = CreateAdjacency(dist, aux->resonanceFrequency, existingIndex);\par
121                 head = InsertAdjacency(head, a2, newIndex, existingIndex, res);\par
122             \}\par
123         \}\par
124         aux = aux->next;\par
125         existingIndex++;\par
126     \}\par
127 \par
128     *res = 1;\par
129     {\cf19 return} head;\par
130 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia ao ficheiro C:/Users/carlo/Desktop/EDA-Project/graph.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/carlo/Desktop/EDA-Project/graph.h}
{\xe \v C:/Users/carlo/Desktop/EDA-Project/graph.h}
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdbool.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Componentes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Vertex}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Adjacency}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Graph}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b QueueNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Queue}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Path}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b M}\~ 40\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es de tipos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b Vertex} {\b Vertex}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b Adjacency} {\b Adjacency}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b Graph} {\b Graph}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b QueueNode} {\b QueueNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b Queue} {\b Queue}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Vertex} * {\b CreateVertex} (char resonanceFrequency, float coordinateX, float coordinateY)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Vertex} * {\b InsertVertex} ({\b Vertex} *newVertex, {\b Vertex} *head, int *res)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b AdjacencyExists} ({\b Vertex} *origin, int destinationIndex)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Adjacency} * {\b CreateAdjacency} (float distance, char resonanceFrequency, int destinationIndex)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Vertex} * {\b InsertAdjacency} ({\b Vertex} *head, {\b Adjacency} *newAdj, int originIndex, int destinationIndex, int *res)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b LoadGraph} (char *fileName, {\b Graph} *graph)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ShowGraph} ({\b Graph} *graph)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ShowGraphAsGrid} ({\b Graph} *graph)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b findIntersections} ({\b Graph} *graph, char freqA, char freqB)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b visitDFT} ({\b Vertex} *v, bool *visited, {\b Graph} *graph, int index)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b DFT_FromCoordinates} (float x, float y, {\b Graph} *graph)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b BFT_FromCoordinates} (float x, float y, {\b Graph} *graph)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b FindAllPathsUtil} ({\b Vertex} *current, int currentIndex, int endIndex, bool *visited, int *path, int pathIndex, {\b Graph} *graph)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b FindAllPaths} ({\b Graph} *graph, float startX, float startY, float endX, float endY)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b CalculateDistance} ({\b Vertex} *a, {\b Vertex} *b)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Enqueue} ({\b Queue} *q, int index)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Dequeue} ({\b Queue} *q)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsQueueEmpty} ({\b Queue} *q)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das macros\par
\pard\plain 
{\xe \v M\:graph.h}
{\xe \v graph.h\:M}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define M\~ 40}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos tipos\par
\pard\plain 
{\xe \v Adjacency\:graph.h}
{\xe \v graph.h\:Adjacency}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b Adjacency} {\b Adjacency}}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Graph\:graph.h}
{\xe \v graph.h\:Graph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b Graph} {\b Graph}}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Queue\:graph.h}
{\xe \v graph.h\:Queue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b Queue} {\b Queue}}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v QueueNode\:graph.h}
{\xe \v graph.h\:QueueNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b QueueNode} {\b QueueNode}}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Vertex\:graph.h}
{\xe \v graph.h\:Vertex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b Vertex} {\b Vertex}}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v AdjacencyExists\:graph.h}
{\xe \v graph.h\:AdjacencyExists}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool AdjacencyExists ({\b Vertex} *  {\i origin}, int  {\i destinationIndex})}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28 \{\par
29     Adjacency *adj = origin->adjacencies;\par
30     {\cf19 while} (adj)\par
31     \{\par
32         {\cf19 if} (adj->destinationVertexIndex == destinationIndex)\par
33             {\cf19 return} {\cf17 true};\par
34         adj = adj->next;\par
35     \}\par
36     {\cf19 return} {\cf17 false};\par
37 \}\par
}
}
{\xe \v BFT_FromCoordinates\:graph.h}
{\xe \v graph.h\:BFT_FromCoordinates}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int BFT_FromCoordinates (float  {\i x}, float  {\i y}, {\b Graph} *  {\i graph})}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 149 \{\par
150     {\cf19 if} (!graph || !graph->head)\par
151     \{\par
152         printf({\cf22 "Grafo vazio.\\n"});\par
153         {\cf19 return} 0;\par
154     \}\par
155 \par
156     Vertex *v = graph->head;\par
157     {\cf18 int} index = 0;\par
158     {\cf19 while} (v && (v->coordinateX != x || v->coordinateY != y))\par
159     \{\par
160         v = v->next;\par
161         index++;\par
162     \}\par
163 \par
164     {\cf19 if} (!v)\par
165     \{\par
166         printf({\cf22 "Antena n\'E3o encontrada nas coordenadas (%.0f, %.0f)\\n"}, x, y);\par
167         {\cf19 return} 0;\par
168     \}\par
169 \par
170     {\cf18 char} targetResonance = v->resonanceFrequency;\par
171     {\cf18 bool} *visited = ({\cf18 bool} *)calloc(graph->numVertices, {\cf17 sizeof}({\cf18 bool}));\par
172     {\cf19 if} (!visited)\par
173     \{\par
174         printf({\cf22 "Erro de mem\'F3ria.\\n"});\par
175         {\cf19 return} 0;\par
176     \}\par
177 \par
178     Queue q = \{NULL, NULL\};\par
179     Enqueue(&q, index);\par
180     visited[index] = {\cf17 true};\par
181 \par
182     printf({\cf22 "BFT a partir da antena %c (%.0f, %.0f):\\n"}, v->resonanceFrequency, x, y);\par
183     {\cf18 int} verticesVisited = 0;\par
184 \par
185     {\cf19 while} (!IsQueueEmpty(&q))\par
186     \{\par
187         {\cf18 int} currentIndex = Dequeue(&q);\par
188         Vertex *curr = graph->head;\par
189         {\cf19 for} ({\cf18 int} i = 0; curr && i < currentIndex; i++)\par
190             curr = curr->next;\par
191 \par
192         {\cf19 if} (curr)\par
193         \{\par
194             verticesVisited++;\par
195             printf({\cf22 "Antena: %c (%.0f, %.0f)\\n"}, curr->resonanceFrequency, curr->coordinateX, curr->coordinateY);\par
196 \par
197             Adjacency *adj = curr->adjacencies;\par
198             {\cf19 while} (adj)\par
199             \{\par
200                 {\cf19 if} (!visited[adj->destinationVertexIndex])\par
201                 \{\par
202                     Vertex *neighbor = graph->head;\par
203                     {\cf19 for} ({\cf18 int} i = 0; neighbor && i < adj->destinationVertexIndex; i++)\par
204                         neighbor = neighbor->next;\par
205 \par
206                     {\cf19 if} (neighbor && neighbor->resonanceFrequency == targetResonance)\par
207                     \{\par
208                         Enqueue(&q, adj->destinationVertexIndex);\par
209                         visited[adj->destinationVertexIndex] = {\cf17 true};\par
210                     \}\par
211                 \}\par
212                 adj = adj->next;\par
213             \}\par
214         \}\par
215     \}\par
216 \par
217     free(visited);\par
218     printf({\cf22 "Total de v\'E9rtices visitados: %d\\n"}, verticesVisited);\par
219     {\cf19 return} verticesVisited;\par
220 \}\par
}
}
{\xe \v CalculateDistance\:graph.h}
{\xe \v graph.h\:CalculateDistance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float CalculateDistance ({\b Vertex} *  {\i a}, {\b Vertex} *  {\i b})}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 136 \{\par
137     {\cf19 return} sqrtf(powf(a->coordinateX - b->coordinateX, 2) + powf(a->coordinateY - b->coordinateY, 2));\par
138 \}\par
}
}
{\xe \v CreateAdjacency\:graph.h}
{\xe \v graph.h\:CreateAdjacency}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Adjacency} * CreateAdjacency (float  {\i distance}, char  {\i resonanceFrequency}, int  {\i destinationIndex})}}
\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 41 \{\par
42     Adjacency *adj = (Adjacency *)malloc({\cf17 sizeof}(Adjacency));\par
43     {\cf19 if} (adj)\par
44     \{\par
45         adj->distance = distance;\par
46         adj->resonanceFrequency = resonanceFrequency; {\cf20 // Agora \'E9 char}\par
47         adj->destinationVertexIndex = destinationIndex;\par
48         adj->next = NULL;\par
49     \}\par
50     {\cf19 return} adj;\par
51 \}\par
}
}
{\xe \v CreateVertex\:graph.h}
{\xe \v graph.h\:CreateVertex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Vertex} * CreateVertex (char  {\i resonanceFrequency}, float  {\i coordinateX}, float  {\i coordinateY})}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13 \{\par
14     Vertex *v = (Vertex *)malloc({\cf17 sizeof}(Vertex));\par
15     {\cf19 if} (v)\par
16     \{\par
17         v->resonanceFrequency = resonanceFrequency;\par
18         v->coordinateX = coordinateX;\par
19         v->coordinateY = coordinateY;\par
20         v->adjacencies = NULL;\par
21         v->next = NULL;\par
22     \}\par
23     {\cf19 return} v;\par
24 \}\par
}
}
{\xe \v Dequeue\:graph.h}
{\xe \v graph.h\:Dequeue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Dequeue ({\b Queue} *  {\i q})}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 129 \{\par
130     {\cf19 if} (!q->front)\par
131         {\cf19 return} -1;\par
132     QueueNode *temp = q->front;\par
133     {\cf18 int} index = temp->index;\par
134     q->front = temp->next;\par
135     {\cf19 if} (!q->front)\par
136         q->rear = NULL;\par
137     free(temp);\par
138     {\cf19 return} index;\par
139 \}\par
}
}
{\xe \v DFT_FromCoordinates\:graph.h}
{\xe \v graph.h\:DFT_FromCoordinates}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int DFT_FromCoordinates (float  {\i x}, float  {\i y}, {\b Graph} *  {\i graph})}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 64 \{\par
65     {\cf19 if} (!graph || !graph->head)\par
66     \{\par
67         printf({\cf22 "Grafo vazio.\\n"});\par
68         {\cf19 return} 0;\par
69     \}\par
70 \par
71     Vertex *v = graph->head;\par
72     {\cf18 int} index = 0;\par
73     {\cf19 while} (v && (v->coordinateX != x || v->coordinateY != y))\par
74     \{\par
75         v = v->next;\par
76         index++;\par
77     \}\par
78 \par
79     {\cf19 if} (!v)\par
80     \{\par
81         printf({\cf22 "Antena n\'E3o encontrada nas coordenadas (%.0f, %.0f)\\n"}, x, y);\par
82         {\cf19 return} 0;\par
83     \}\par
84 \par
85     {\cf18 bool} *visited = ({\cf18 bool} *)calloc(graph->numVertices, {\cf17 sizeof}({\cf18 bool}));\par
86     {\cf19 if} (!visited)\par
87     \{\par
88         printf({\cf22 "Erro de mem\'F3ria.\\n"});\par
89         {\cf19 return} 0;\par
90     \}\par
91 \par
92     printf({\cf22 "DFT a partir da antena %c (%.0f, %.0f):\\n"}, v->resonanceFrequency, x, y);\par
93     {\cf18 int} verticesVisited = visitDFT(v, visited, graph, index);\par
94     free(visited);\par
95 \par
96     printf({\cf22 "Total de v\'E9rtices visitados: %d\\n"}, verticesVisited);\par
97     {\cf19 return} verticesVisited;\par
98 \}\par
}
}
{\xe \v Enqueue\:graph.h}
{\xe \v graph.h\:Enqueue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Enqueue ({\b Queue} *  {\i q}, int  {\i index})}}
\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 103 \{\par
104     {\cf19 if} (q == NULL)\par
105         {\cf19 return} 0;\par
106 \par
107     QueueNode *newNode = (QueueNode *)malloc({\cf17 sizeof}(QueueNode));\par
108     {\cf19 if} (newNode == NULL)\par
109         {\cf19 return} 0;\par
110 \par
111     newNode->index = index;\par
112     newNode->next = NULL;\par
113 \par
114     {\cf19 if} (q->rear == NULL)\par
115     \{\par
116         q->front = q->rear = newNode;\par
117     \}\par
118     {\cf19 else}\par
119     \{\par
120         q->rear->next = newNode;\par
121         q->rear = newNode;\par
122     \}\par
123 \par
124     {\cf19 return} 1;\par
125 \}\par
}
}
{\xe \v FindAllPaths\:graph.h}
{\xe \v graph.h\:FindAllPaths}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int FindAllPaths ({\b Graph} *  {\i graph}, float  {\i startX}, float  {\i startY}, float  {\i endX}, float  {\i endY})}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 288 \{\par
289     {\cf19 if} (!graph || !graph->head)\par
290     \{\par
291         printf({\cf22 "Grafo vazio.\\n"});\par
292         {\cf19 return} 0;\par
293     \}\par
294 \par
295     Vertex *start = graph->head;\par
296     Vertex *end = graph->head;\par
297     {\cf18 int} startIndex = 0, endIndex = 0;\par
298     {\cf18 bool} startFound = {\cf17 false}, endFound = {\cf17 false};\par
299 \par
300     {\cf20 // Procura os v\'E9rtices correspondentes \'E0s coordenadas de in\'EDcio e fim}\par
301     Vertex *current = graph->head;\par
302     {\cf18 int} index = 0;\par
303     {\cf19 while} (current)\par
304     \{\par
305         {\cf19 if} (!startFound && current->coordinateX == startX && current->coordinateY == startY)\par
306         \{\par
307             start = current;\par
308             startIndex = index;\par
309             startFound = {\cf17 true};\par
310         \}\par
311 \par
312         {\cf19 if} (!endFound && current->coordinateX == endX && current->coordinateY == endY)\par
313         \{\par
314             end = current;\par
315             endIndex = index;\par
316             endFound = {\cf17 true};\par
317         \}\par
318 \par
319         current = current->next;\par
320         index++;\par
321     \}\par
322 \par
323     {\cf20 // Verifica se ambos os v\'E9rtices foram encontrados}\par
324     {\cf19 if} (!startFound || !endFound)\par
325     \{\par
326         printf({\cf22 "Antenas inicial ou final n\'E3o encontradas.\\n"});\par
327         {\cf19 return} 0;\par
328     \}\par
329 \par
330     {\cf20 // Verifica se ambos os v\'E9rtices possuem a mesma frequ\'EAncia de resson\'E2ncia}\par
331     {\cf19 if} (start->resonanceFrequency != end->resonanceFrequency)\par
332     \{\par
333         printf({\cf22 "As antenas n\'E3o t\'EAm a mesma frequ\'EAncia.\\n"});\par
334         {\cf19 return} 0;\par
335     \}\par
336 \par
337     {\cf20 // Aloca mem\'F3ria para controlar os v\'E9rtices visitados e o caminho atual}\par
338     {\cf18 bool} *visited = ({\cf18 bool} *)calloc(graph->numVertices, {\cf17 sizeof}({\cf18 bool}));\par
339     {\cf18 int} *path = ({\cf18 int} *)malloc(graph->numVertices * {\cf17 sizeof}({\cf18 int}));\par
340 \par
341     {\cf20 // Mostra as informa\'E7\'F5es de in\'EDcio e fim}\par
342     printf({\cf22 "Todos os caminhos de %c(%.0f,%.0f) a %c(%.0f,%.0f):\\n"},\par
343            start->resonanceFrequency, startX, startY,\par
344            end->resonanceFrequency, endX, endY);\par
345 \par
346     {\cf20 // Inicia a procura pelos caminhos}\par
347     {\cf18 int} totalPaths = FindAllPathsUtil(start, startIndex, endIndex, visited, path, 0, graph);\par
348 \par
349     {\cf20 // Mostra o n\'FAmero total de caminhos encontrados}\par
350     printf({\cf22 "Total de caminhos encontrados: %d\\n"}, totalPaths);\par
351 \par
352     {\cf20 // Liberta mem\'F3ria alocada}\par
353     free(visited);\par
354     free(path);\par
355     {\cf19 return} totalPaths;\par
356 \}\par
}
}
{\xe \v FindAllPathsUtil\:graph.h}
{\xe \v graph.h\:FindAllPathsUtil}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int FindAllPathsUtil ({\b Vertex} *  {\i current}, int  {\i currentIndex}, int  {\i endIndex}, bool *  {\i visited}, int *  {\i path}, int  {\i pathIndex}, {\b Graph} *  {\i graph})}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 225 \{\par
226     {\cf18 int} pathCount = 0;\par
227 \par
228     {\cf20 // Marca o v\'E9rtice atual como visitado}\par
229     visited[currentIndex] = {\cf17 true};\par
230 \par
231     {\cf20 // Adiciona o \'EDndice atual ao caminho}\par
232     path[pathIndex] = currentIndex;\par
233     pathIndex++;\par
234 \par
235     {\cf20 // Se o v\'E9rtice atual \'E9 o destino, mostra o caminho completo}\par
236     {\cf19 if} (currentIndex == endIndex)\par
237     \{\par
238         pathCount++;\par
239         {\cf19 for} ({\cf18 int} i = 0; i < pathIndex; i++)\par
240         \{\par
241             {\cf20 // Navega at\'E9 o v\'E9rtice correspondente ao \'EDndice armazenado}\par
242             Vertex *v = graph->head;\par
243             {\cf19 for} ({\cf18 int} j = 0; j < path[i]; j++)\par
244                 v = v->next;\par
245 \par
246             {\cf20 // Mostra o v\'E9rtice no formato: letra(frequ\'EAncia)(x,y)}\par
247             printf({\cf22 "%c(%.0f,%.0f)"}, v->resonanceFrequency, v->coordinateX, v->coordinateY);\par
248 \par
249             {\cf19 if} (i < pathIndex - 1)\par
250                 printf({\cf22 " -> "});\par
251         \}\par
252         printf({\cf22 "\\n"});\par
253     \}\par
254     {\cf19 else}\par
255     \{\par
256         {\cf20 // Percorre todas as adjac\'EAncias do v\'E9rtice atual}\par
257         Adjacency *adj = current->adjacencies;\par
258         {\cf19 while} (adj)\par
259         \{\par
260             {\cf20 // Se o v\'E9rtice destino ainda n\'E3o foi visitado}\par
261             {\cf19 if} (!visited[adj->destinationVertexIndex])\par
262             \{\par
263                 {\cf20 // Encontra o pr\'F3ximo v\'E9rtice com base no \'EDndice de destino}\par
264                 Vertex *next = graph->head;\par
265                 {\cf19 for} ({\cf18 int} i = 0; i < adj->destinationVertexIndex; i++)\par
266                     next = next->next;\par
267 \par
268                 {\cf20 // S\'F3 continua a procura se a frequ\'EAncia for a mesma}\par
269                 {\cf19 if} (next && next->resonanceFrequency == current->resonanceFrequency)\par
270                 \{\par
271                     {\cf20 // Chamada recursiva para continuar a procura a partir do v\'E9rtice adjacente}\par
272                     pathCount += FindAllPathsUtil(next, adj->destinationVertexIndex, endIndex, visited, path, pathIndex, graph);\par
273                 \}\par
274             \}\par
275             {\cf20 // Avan\'E7a para a pr\'F3xima adjac\'EAncia}\par
276             adj = adj->next;\par
277         \}\par
278     \}\par
279 \par
280     {\cf20 // Backtracking: desmarca o v\'E9rtice como visitado e retrocede o caminho}\par
281     visited[currentIndex] = {\cf17 false};\par
282     pathIndex--;\par
283     {\cf19 return} pathCount;\par
284 \}\par
}
}
{\xe \v findIntersections\:graph.h}
{\xe \v graph.h\:findIntersections}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int findIntersections ({\b Graph} *  {\i graph}, char  {\i freqA}, char  {\i freqB})}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15 \{\par
16     printf({\cf22 "\\nProcura de intersec\'E7\'F5es entre %c e %c:\\n"}, freqA, freqB);\par
17 \par
18     Path pathsA[100], pathsB[100]; {\cf20 // Arrays para armazenar caminhos das frequ\'EAncias A e B}\par
19     {\cf18 int} countA = 0, countB = 0;    {\cf20 // Contadores de caminhos \'FAnicos encontrados}\par
20     {\cf18 int} intersectionCount = 0;     {\cf20 // Contador de intersec\'E7\'F5es encontradas}\par
21 \par
22     {\cf20 // Recolha de caminhos entre v\'E9rtices com frequ\'EAncia freqA (sem duplica\'E7\'E3o)}\par
23     Vertex *current = graph->head;\par
24     {\cf19 while} (current != NULL)\par
25     \{\par
26         {\cf19 if} (current->resonanceFrequency == freqA)\par
27         \{\par
28             Adjacency *adj = current->adjacencies;\par
29             {\cf19 while} (adj != NULL)\par
30             \{\par
31                 {\cf20 // Achar o v\'E9rtice de destino com base no \'EDndice}\par
32                 Vertex *dest = graph->head;\par
33                 {\cf19 for} ({\cf18 int} i = 0; i < adj->destinationVertexIndex && dest != NULL; i++)\par
34                     dest = dest->next;\par
35 \par
36                 {\cf20 // Se destino \'E9 v\'E1lido e tem a mesma frequ\'EAncia}\par
37                 {\cf19 if} (dest != NULL && dest->resonanceFrequency == freqA)\par
38                 \{\par
39                     {\cf20 // Verificar se o caminho j\'E1 foi adicionado (em qualquer dire\'E7\'E3o)}\par
40                     {\cf18 bool} exists = {\cf17 false};\par
41                     {\cf19 for} ({\cf18 int} i = 0; i < countA; i++)\par
42                     \{\par
43                         {\cf19 if} ((pathsA[i].start == current && pathsA[i].end == dest) ||\par
44                             (pathsA[i].start == dest && pathsA[i].end == current))\par
45                         \{\par
46                             exists = {\cf17 true};\par
47                             {\cf19 break};\par
48                         \}\par
49                     \}\par
50 \par
51                     {\cf20 // Se n\'E3o existe, adicionar ao array de caminhos}\par
52                     {\cf19 if} (!exists)\par
53                     \{\par
54                         pathsA[countA].start = current;\par
55                         pathsA[countA].end = dest;\par
56                         pathsA[countA].processed = {\cf17 false};\par
57                         countA++;\par
58                     \}\par
59                 \}\par
60                 adj = adj->next;\par
61             \}\par
62         \}\par
63         current = current->next;\par
64     \}\par
65 \par
66     {\cf20 // Recolha de caminhos entre v\'E9rtices com frequ\'EAncia freqB (sem duplica\'E7\'E3o)}\par
67     current = graph->head;\par
68     {\cf19 while} (current != NULL)\par
69     \{\par
70         {\cf19 if} (current->resonanceFrequency == freqB)\par
71         \{\par
72             Adjacency *adj = current->adjacencies;\par
73             {\cf19 while} (adj != NULL)\par
74             \{\par
75                 {\cf20 // Achar o v\'E9rtice de destino com base no \'EDndice}\par
76                 Vertex *dest = graph->head;\par
77                 {\cf19 for} ({\cf18 int} i = 0; i < adj->destinationVertexIndex && dest != NULL; i++)\par
78                     dest = dest->next;\par
79 \par
80                 {\cf19 if} (dest != NULL && dest->resonanceFrequency == freqB)\par
81                 \{\par
82                     {\cf20 // Verificar duplica\'E7\'E3o de caminho}\par
83                     {\cf18 bool} exists = {\cf17 false};\par
84                     {\cf19 for} ({\cf18 int} i = 0; i < countB; i++)\par
85                     \{\par
86                         {\cf19 if} ((pathsB[i].start == current && pathsB[i].end == dest) ||\par
87                             (pathsB[i].start == dest && pathsB[i].end == current))\par
88                         \{\par
89                             exists = {\cf17 true};\par
90                             {\cf19 break};\par
91                         \}\par
92                     \}\par
93 \par
94                     {\cf20 // Adicionar caminho novo}\par
95                     {\cf19 if} (!exists)\par
96                     \{\par
97                         pathsB[countB].start = current;\par
98                         pathsB[countB].end = dest;\par
99                         pathsB[countB].processed = {\cf17 false};\par
100                         countB++;\par
101                     \}\par
102                 \}\par
103                 adj = adj->next;\par
104             \}\par
105         \}\par
106         current = current->next;\par
107     \}\par
108 \par
109     {\cf20 // Verifica\'E7\'E3o de intersec\'E7\'F5es entre os caminhos de freqA e freqB}\par
110     {\cf18 bool} found = {\cf17 false};\par
111     {\cf19 for} ({\cf18 int} i = 0; i < countA; i++)\par
112     \{\par
113         {\cf19 for} ({\cf18 int} j = 0; j < countB; j++)\par
114         \{\par
115             {\cf20 // Apenas verificar caminhos que ainda n\'E3o foram processados}\par
116             {\cf19 if} (!pathsA[i].processed && !pathsB[j].processed)\par
117             \{\par
118                 {\cf20 // Coordenadas do primeiro segmento (freqA)}\par
119                 {\cf18 float} x1 = pathsA[i].start->coordinateX;\par
120                 {\cf18 float} y1 = pathsA[i].start->coordinateY;\par
121                 {\cf18 float} x2 = pathsA[i].end->coordinateX;\par
122                 {\cf18 float} y2 = pathsA[i].end->coordinateY;\par
123 \par
124                 {\cf20 // Coordenadas do segundo segmento (freqB)}\par
125                 {\cf18 float} x3 = pathsB[j].start->coordinateX;\par
126                 {\cf18 float} y3 = pathsB[j].start->coordinateY;\par
127                 {\cf18 float} x4 = pathsB[j].end->coordinateX;\par
128                 {\cf18 float} y4 = pathsB[j].end->coordinateY;\par
129 \par
130                 {\cf20 // C\'E1lculo da intersec\'E7\'E3o usando determinantes (f\'F3rmulas padr\'E3o)}\par
131                 {\cf18 float} denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\par
132 \par
133                 {\cf20 // Se as retas n\'E3o forem paralelas}\par
134                 {\cf19 if} (denom != 0)\par
135                 \{\par
136                     {\cf18 float} ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;\par
137                     {\cf18 float} ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;\par
138 \par
139                     {\cf20 // Verifica se a intersec\'C3\'A7\'C3\'A3o est\'C3\'A1 dentro dos segmentos (0 \'E2\'89\'A4 u \'E2\'89\'A4 1)}\par
140                     {\cf19 if} (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1)\par
141                     \{\par
142                         printf({\cf22 "Intersec\'E7\'E3o encontrada:\\n"});\par
143                         printf({\cf22 "Entre %c(%.0f,%.0f) -> %c(%.0f,%.0f) e "},\par
144                                freqA, x1, y1, freqA, x2, y2);\par
145                         printf({\cf22 "%c(%.0f,%.0f) -> %c(%.0f,%.0f)\\n"},\par
146                                freqB, x3, y3, freqB, x4, y4);\par
147 \par
148                         found = {\cf17 true};\par
149                         intersectionCount++;\par
150 \par
151                         {\cf20 // Marca os caminhos como processados para evitar recontagem}\par
152                         pathsA[i].processed = {\cf17 true};\par
153                         pathsB[j].processed = {\cf17 true};\par
154                     \}\par
155                 \}\par
156             \}\par
157         \}\par
158     \}\par
159 \par
160     {\cf20 // Mensagem caso nenhuma intersec\'E7\'E3o tenha sido encontrada}\par
161     {\cf19 if} (!found)\par
162     \{\par
163         printf({\cf22 "Nenhuma intersec\'E7\'E3o encontrada.\\n"});\par
164     \}\par
165 \par
166     {\cf19 return} intersectionCount;\par
167 \}\par
}
}
{\xe \v InsertAdjacency\:graph.h}
{\xe \v graph.h\:InsertAdjacency}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Vertex} * InsertAdjacency ({\b Vertex} *  {\i head}, {\b Adjacency} *  {\i newAdj}, int  {\i originIndex}, int  {\i destinationIndex}, int *  {\i res})}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 55 \{\par
56     {\cf19 if} (!head || !newAdj)\par
57     \{\par
58         *res = 0;\par
59         {\cf19 return} head;\par
60     \}\par
61 \par
62     Vertex *origin = head;\par
63     {\cf19 for} ({\cf18 int} i = 0; origin && i < originIndex; i++)\par
64         origin = origin->next;\par
65     Vertex *dest = head;\par
66     {\cf19 for} ({\cf18 int} i = 0; dest && i < destinationIndex; i++)\par
67         dest = dest->next;\par
68 \par
69     {\cf19 if} (!origin || !dest)\par
70     \{\par
71         *res = 0;\par
72         {\cf19 return} head;\par
73     \}\par
74 \par
75     newAdj->next = origin->adjacencies;\par
76     origin->adjacencies = newAdj;\par
77     *res = 1;\par
78     {\cf19 return} head;\par
79 \}\par
}
}
{\xe \v InsertVertex\:graph.h}
{\xe \v graph.h\:InsertVertex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Vertex} * InsertVertex ({\b Vertex} *  {\i newVertex}, {\b Vertex} *  {\i head}, int *  {\i res})}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 83 \{\par
84     {\cf19 if} (!newVertex)\par
85     \{\par
86         *res = 0;\par
87         {\cf19 return} head;\par
88     \}\par
89 \par
90     {\cf19 if} (!head)\par
91     \{\par
92         *res = 1;\par
93         {\cf19 return} newVertex;\par
94     \}\par
95 \par
96     Vertex *last = head;\par
97     {\cf18 int} newIndex = 0;\par
98     {\cf19 while} (last->next)\par
99     \{\par
100         last = last->next;\par
101         newIndex++;\par
102     \}\par
103     last->next = newVertex;\par
104     newIndex++;\par
105 \par
106     Vertex *aux = head;\par
107     {\cf18 int} existingIndex = 0;\par
108     {\cf19 while} (aux)\par
109     \{\par
110         {\cf19 if} (aux->resonanceFrequency == newVertex->resonanceFrequency)\par
111         \{\par
112             {\cf18 float} dist = CalculateDistance(aux, newVertex);\par
113             {\cf19 if} (!AdjacencyExists(aux, newIndex))\par
114             \{\par
115                 Adjacency *a1 = CreateAdjacency(dist, newVertex->resonanceFrequency, newIndex);\par
116                 head = InsertAdjacency(head, a1, existingIndex, newIndex, res);\par
117             \}\par
118             {\cf19 if} (!AdjacencyExists(newVertex, existingIndex))\par
119             \{\par
120                 Adjacency *a2 = CreateAdjacency(dist, aux->resonanceFrequency, existingIndex);\par
121                 head = InsertAdjacency(head, a2, newIndex, existingIndex, res);\par
122             \}\par
123         \}\par
124         aux = aux->next;\par
125         existingIndex++;\par
126     \}\par
127 \par
128     *res = 1;\par
129     {\cf19 return} head;\par
130 \}\par
}
}
{\xe \v IsQueueEmpty\:graph.h}
{\xe \v graph.h\:IsQueueEmpty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool IsQueueEmpty ({\b Queue} *  {\i q})}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 143 \{\par
144     {\cf19 return} q->front == NULL;\par
145 \}\par
}
}
{\xe \v LoadGraph\:graph.h}
{\xe \v graph.h\:LoadGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool LoadGraph (char *  {\i fileName}, {\b Graph} *  {\i graph})}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14 \{\par
15     FILE *file = fopen(fileName, {\cf22 "r"});\par
16     {\cf19 if} (!file)\par
17     \{\par
18         printf({\cf22 "Erro a carregar o ficheiro '%s'.\\n"}, fileName);\par
19         {\cf19 return} {\cf17 false};\par
20     \}\par
21 \par
22     {\cf18 char} line[256];\par
23     {\cf18 int} y = 1;\par
24     {\cf19 while} (fgets(line, {\cf17 sizeof}(line), file))\par
25     \{\par
26         {\cf18 int} x = 1;\par
27         {\cf19 for} ({\cf18 int} i = 0; line[i]; i++)\par
28         \{\par
29             {\cf19 if} (line[i] == {\cf23 ' '} || line[i] == {\cf23 '\\n'})\par
30                 {\cf19 continue};\par
31 \par
32             {\cf19 if} (isalpha(line[i]))\par
33             \{\par
34                 Vertex *v = CreateVertex(line[i], ({\cf18 float})x, ({\cf18 float})y);\par
35                 {\cf18 int} res;\par
36                 graph->head = InsertVertex(v, graph->head, &res);\par
37                 {\cf19 if} (res)\par
38                     graph->numVertices++;\par
39             \}\par
40             x++;\par
41         \}\par
42 \par
43         y++;\par
44     \}\par
45 \par
46     fclose(file);\par
47     {\cf19 return} {\cf17 true};\par
48 \}\par
}
}
{\xe \v ShowGraph\:graph.h}
{\xe \v graph.h\:ShowGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ShowGraph ({\b Graph} *  {\i graph})}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 52 \{\par
53     {\cf19 if} (!g || !g->head)\par
54     \{\par
55         printf({\cf22 "Grafo vazio.\\n"});\par
56         {\cf19 return} 0;\par
57     \}\par
58 \par
59     {\cf18 int} count = 0;\par
60     Vertex *v = g->head;\par
61     {\cf18 int} originIndex = 0;\par
62     {\cf19 while} (v)\par
63     \{\par
64         printf({\cf22 "%c(%.0f,%.0f)"}, v->resonanceFrequency, v->coordinateX, v->coordinateY);\par
65         Adjacency *adj = v->adjacencies;\par
66         {\cf19 while} (adj)\par
67         \{\par
68             {\cf19 if} (adj->destinationVertexIndex != originIndex)\par
69             \{\par
70                 Vertex *dest = g->head;\par
71                 {\cf19 for} ({\cf18 int} i = 0; dest && i < adj->destinationVertexIndex; i++)\par
72                     dest = dest->next;\par
73                 {\cf19 if} (dest && dest->resonanceFrequency == v->resonanceFrequency)\par
74                     printf({\cf22 " -> %c(%.0f,%.0f)"}, dest->resonanceFrequency, dest->coordinateX, dest->coordinateY);\par
75             \}\par
76             adj = adj->next;\par
77         \}\par
78         printf({\cf22 "\\n"});\par
79         v = v->next;\par
80         originIndex++;\par
81         count++;\par
82     \}\par
83     {\cf19 return} count;\par
84 \}\par
}
}
{\xe \v ShowGraphAsGrid\:graph.h}
{\xe \v graph.h\:ShowGraphAsGrid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ShowGraphAsGrid ({\b Graph} *  {\i graph})}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 88 \{\par
89     {\cf19 if} (!graph || !graph->head)\par
90     \{\par
91         printf({\cf22 "Grafo vazio.\\n"});\par
92         {\cf19 return} 0;\par
93     \}\par
94 \par
95     {\cf18 char} grid[M][M];\par
96     {\cf19 for} ({\cf18 int} i = 0; i < M; i++)\par
97         {\cf19 for} ({\cf18 int} j = 0; j < M; j++)\par
98             grid[i][j] = {\cf23 '.'};\par
99 \par
100     {\cf18 int} maxX = 0, maxY = 0;\par
101     {\cf18 int} count = 0;\par
102 \par
103     Vertex *v = graph->head;\par
104     {\cf19 while} (v)\par
105     \{\par
106         {\cf18 int} x = (int)(v->coordinateX) - 1;\par
107         {\cf18 int} y = (int)(v->coordinateY) - 1;\par
108 \par
109         {\cf19 if} (x >= 0 && x < M && y >= 0 && y < M)\par
110         \{\par
111             grid[y][x] = v->resonanceFrequency;\par
112             {\cf19 if} (x > maxX)\par
113                 maxX = x;\par
114             {\cf19 if} (y > maxY)\par
115                 maxY = y;\par
116             count++;\par
117         \}\par
118 \par
119         v = v->next;\par
120     \}\par
121 \par
122     printf({\cf22 "\\n--- Grafo em grid ---\\n"});\par
123 \par
124     {\cf19 for} ({\cf18 int} i = 0; i <= maxY; i++)\par
125     \{\par
126         {\cf19 for} ({\cf18 int} j = 0; j <= maxX; j++)\par
127         \{\par
128             printf({\cf22 "%c "}, grid[i][j]);\par
129         \}\par
130         printf({\cf22 "\\n"});\par
131     \}\par
132 \par
133     {\cf19 return} count;\par
134 \}\par
}
}
{\xe \v visitDFT\:graph.h}
{\xe \v graph.h\:visitDFT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int visitDFT ({\b Vertex} *  {\i v}, bool *  {\i visited}, {\b Graph} *  {\i graph}, int  {\i index})}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14 \{\par
15     {\cf19 if} (!v)\par
16         {\cf19 return} 0;\par
17 \par
18     {\cf18 int} count = 1; {\cf20 // Conta o v\'E9rtice atual}\par
19     visited[index] = {\cf17 true};\par
20     printf({\cf22 "Antena: %c (%.0f, %.0f)\\n"}, v->resonanceFrequency, v->coordinateX, v->coordinateY);\par
21 \par
22     {\cf20 // Criar uma lista tempor\'E1ria de adjac\'EAncias}\par
23     Adjacency *adjList = NULL;\par
24     Adjacency *adj = v->adjacencies;\par
25 \par
26     {\cf20 // Copiar as adjac\'EAncias para uma lista tempor\'E1ria}\par
27     {\cf19 while} (adj)\par
28     \{\par
29         Adjacency *newAdj = CreateAdjacency(adj->distance, adj->resonanceFrequency, adj->destinationVertexIndex);\par
30         newAdj->next = adjList;\par
31         adjList = newAdj;\par
32         adj = adj->next;\par
33     \}\par
34 \par
35     {\cf20 // Visitar cada adjac\'EAncia}\par
36     adj = adjList;\par
37     {\cf19 while} (adj)\par
38     \{\par
39         {\cf19 if} (!visited[adj->destinationVertexIndex])\par
40         \{\par
41             Vertex *next = graph->head;\par
42             {\cf19 for} ({\cf18 int} i = 0; next && i < adj->destinationVertexIndex; i++)\par
43                 next = next->next;\par
44 \par
45             {\cf19 if} (next && next->resonanceFrequency == v->resonanceFrequency)\par
46                 count += visitDFT(next, visited, graph, adj->destinationVertexIndex);\par
47         \}\par
48         adj = adj->next;\par
49     \}\par
50 \par
51     {\cf20 // Libertar a lista tempor\'E1ria}\par
52     {\cf19 while} (adjList)\par
53     \{\par
54         Adjacency *temp = adjList;\par
55         adjList = adjList->next;\par
56         free(temp);\par
57     \}\par
58 \par
59     {\cf19 return} count;\par
60 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
graph.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/carlo/Desktop/EDA-Project/graph.h}
{\xe \v C:/Users/carlo/Desktop/EDA-Project/graph.h}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
Ir para a documenta\'E7\'E3o deste ficheiro.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 // File: graph.h}\par
2 {\cf20 // Desc:}\par
3 {\cf20 // Auth: Carlos Barreiro}\par
4 {\cf20 // Mail: a20360@alunos.ipca.pt}\par
5 {\cf20 // Date: 2025/05}\par
6 \par
7 {\cf21 #ifndef GRAPH_H}\par
8 {\cf21 #define GRAPH_H}\par
9 \par
10 {\cf21 #include <stdbool.h>}\par
11 \par
12 {\cf21 #define M 40 }{\cf20 // Tamanho m\'E1ximo do grid (40x40)}\par
13 \par
14 {\cf20 // Representa\'E7\'E3o de um v\'E9rtice no grafo}\par
15 {\cf17 typedef} {\cf17 struct }Vertex\par
16 \{\par
17     {\cf18 char} resonanceFrequency;        {\cf20 // Frequ\'EAncia de resson\'E2ncia}\par
18     {\cf18 float} coordinateX, coordinateY; {\cf20 // Coordenadas da antena}\par
19     {\cf17 struct }Vertex *next;            {\cf20 // Pr\'F3ximo v\'E9rtice}\par
20     {\cf17 struct }Adjacency *adjacencies;  {\cf20 // Lista de adjac\'EAncias}\par
21 \} Vertex;\par
22 \par
23 {\cf20 // Representa\'E7\'E3o de uma aresta no grafo}\par
24 {\cf17 typedef} {\cf17 struct }Adjacency\par
25 \{\par
26     {\cf18 float} distance;             {\cf20 // Dist\'E2ncia at\'E9 o v\'E9rtice adjacente}\par
27     {\cf18 char} resonanceFrequency;    {\cf20 // Frequ\'EAncia de resson\'E2ncia do v\'E9rtice adjacente}\par
28     {\cf18 int} destinationVertexIndex; {\cf20 // \'CDndice do v\'E9rtice adjacente}\par
29     {\cf17 struct }Adjacency *next;     {\cf20 // Pr\'F3xima aresta}\par
30 \} Adjacency;\par
31 \par
32 {\cf20 // Representa\'E7\'E3o do grafo}\par
33 {\cf17 typedef} {\cf17 struct }Graph\par
34 \{\par
35     {\cf18 int} numVertices; {\cf20 // Quantidade de v\'E9rtices}\par
36     Vertex *head;    {\cf20 // Ponteiro para o primeiro v\'E9rtice}\par
37 \} Graph;\par
38 \par
39 {\cf20 // Representa\'E7\'E3o de uma fila para BFT}\par
40 {\cf17 typedef} {\cf17 struct }QueueNode\par
41 \{\par
42     {\cf18 int} index;              {\cf20 // \'CDndice do v\'E9rtice na fila}\par
43     {\cf17 struct }QueueNode *next; {\cf20 // Pr\'F3ximo n\'F3 na fila}\par
44 \} QueueNode;\par
45 \par
46 {\cf20 // Representa\'E7\'E3o de uma fila}\par
47 {\cf17 typedef} {\cf17 struct }Queue\par
48 \{\par
49     QueueNode *front, *rear; {\cf20 // Ponteiros para o in\'EDcio e fim da fila}\par
50 \} Queue;\par
51 \par
52 {\cf20 // Lista de caminhos para cada frequ\'EAncia}\par
53 {\cf17 typedef} {\cf17 struct}\par
54 \{\par
55     Vertex *start;  {\cf20 // V\'E9rtice inicial}\par
56     Vertex *end;    {\cf20 // V\'E9rtice final}\par
57     {\cf18 bool} processed; {\cf20 // Para evitar duplicados}\par
58 \} Path;\par
59 \par
60 {\cf20 // Inicializa\'E7\'E3o e gest\'E3o de gr\'E1ficos}\par
61 Vertex *CreateVertex({\cf18 char} resonanceFrequency, {\cf18 float} coordinateX, {\cf18 float} coordinateY);\par
62 Vertex *InsertVertex(Vertex *newVertex, Vertex *head, {\cf18 int} *res);\par
63 {\cf18 bool} AdjacencyExists(Vertex *origin, {\cf18 int} destinationIndex);\par
64 Adjacency *CreateAdjacency({\cf18 float} distance, {\cf18 char} resonanceFrequency, {\cf18 int} destinationIndex);\par
65 Vertex *InsertAdjacency(Vertex *head, Adjacency *newAdj, {\cf18 int} originIndex, {\cf18 int} destinationIndex, {\cf18 int} *res);\par
66 {\cf18 bool} LoadGraph({\cf18 char} *fileName, Graph *graph);\par
67 {\cf18 int} ShowGraph(Graph *graph);\par
68 {\cf18 int} ShowGraphAsGrid(Graph *graph);\par
69 {\cf18 int} findIntersections(Graph *graph, {\cf18 char} freqA, {\cf18 char} freqB);\par
70 \par
71 {\cf20 // Algoritmos de procura}\par
72 {\cf18 int} visitDFT(Vertex *v, {\cf18 bool} *visited, Graph *graph, {\cf18 int} index);\par
73 {\cf18 int} DFT_FromCoordinates({\cf18 float} x, {\cf18 float} y, Graph *graph);\par
74 {\cf18 int} BFT_FromCoordinates({\cf18 float} x, {\cf18 float} y, Graph *graph);\par
75 {\cf18 int} FindAllPathsUtil(Vertex *current, {\cf18 int} currentIndex, {\cf18 int} endIndex, {\cf18 bool} *visited, {\cf18 int} *path, {\cf18 int} pathIndex, Graph *graph);\par
76 {\cf18 int} FindAllPaths(Graph *graph, {\cf18 float} startX, {\cf18 float} startY, {\cf18 float} endX, {\cf18 float} endY);\par
77 \par
78 {\cf20 // Func\'F5es auxiliares}\par
79 {\cf18 float} CalculateDistance(Vertex *a, Vertex *b);\par
80 \par
81 {\cf20 // BFT}\par
82 {\cf18 int} Enqueue(Queue *q, {\cf18 int} index);\par
83 {\cf18 int} Dequeue(Queue *q);\par
84 {\cf18 bool} IsQueueEmpty(Queue *q);\par
85 \par
86 {\cf21 #endif }{\cf20 // GRAPH_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia ao ficheiro C:/Users/carlo/Desktop/EDA-Project/graphIO.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/carlo/Desktop/EDA-Project/graphIO.c}
{\xe \v C:/Users/carlo/Desktop/EDA-Project/graphIO.c}
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "graph.h"}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <ctype.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b LoadGraph} (char *fileName, {\b Graph} *graph)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ShowGraph} ({\b Graph} *g)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ShowGraphAsGrid} ({\b Graph} *graph)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v LoadGraph\:graphIO.c}
{\xe \v graphIO.c\:LoadGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool LoadGraph (char *  {\i fileName}, {\b Graph} *  {\i graph})}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14 \{\par
15     FILE *file = fopen(fileName, {\cf22 "r"});\par
16     {\cf19 if} (!file)\par
17     \{\par
18         printf({\cf22 "Erro a carregar o ficheiro '%s'.\\n"}, fileName);\par
19         {\cf19 return} {\cf17 false};\par
20     \}\par
21 \par
22     {\cf18 char} line[256];\par
23     {\cf18 int} y = 1;\par
24     {\cf19 while} (fgets(line, {\cf17 sizeof}(line), file))\par
25     \{\par
26         {\cf18 int} x = 1;\par
27         {\cf19 for} ({\cf18 int} i = 0; line[i]; i++)\par
28         \{\par
29             {\cf19 if} (line[i] == {\cf23 ' '} || line[i] == {\cf23 '\\n'})\par
30                 {\cf19 continue};\par
31 \par
32             {\cf19 if} (isalpha(line[i]))\par
33             \{\par
34                 Vertex *v = CreateVertex(line[i], ({\cf18 float})x, ({\cf18 float})y);\par
35                 {\cf18 int} res;\par
36                 graph->head = InsertVertex(v, graph->head, &res);\par
37                 {\cf19 if} (res)\par
38                     graph->numVertices++;\par
39             \}\par
40             x++;\par
41         \}\par
42 \par
43         y++;\par
44     \}\par
45 \par
46     fclose(file);\par
47     {\cf19 return} {\cf17 true};\par
48 \}\par
}
}
{\xe \v ShowGraph\:graphIO.c}
{\xe \v graphIO.c\:ShowGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ShowGraph ({\b Graph} *  {\i g})}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 52 \{\par
53     {\cf19 if} (!g || !g->head)\par
54     \{\par
55         printf({\cf22 "Grafo vazio.\\n"});\par
56         {\cf19 return} 0;\par
57     \}\par
58 \par
59     {\cf18 int} count = 0;\par
60     Vertex *v = g->head;\par
61     {\cf18 int} originIndex = 0;\par
62     {\cf19 while} (v)\par
63     \{\par
64         printf({\cf22 "%c(%.0f,%.0f)"}, v->resonanceFrequency, v->coordinateX, v->coordinateY);\par
65         Adjacency *adj = v->adjacencies;\par
66         {\cf19 while} (adj)\par
67         \{\par
68             {\cf19 if} (adj->destinationVertexIndex != originIndex)\par
69             \{\par
70                 Vertex *dest = g->head;\par
71                 {\cf19 for} ({\cf18 int} i = 0; dest && i < adj->destinationVertexIndex; i++)\par
72                     dest = dest->next;\par
73                 {\cf19 if} (dest && dest->resonanceFrequency == v->resonanceFrequency)\par
74                     printf({\cf22 " -> %c(%.0f,%.0f)"}, dest->resonanceFrequency, dest->coordinateX, dest->coordinateY);\par
75             \}\par
76             adj = adj->next;\par
77         \}\par
78         printf({\cf22 "\\n"});\par
79         v = v->next;\par
80         originIndex++;\par
81         count++;\par
82     \}\par
83     {\cf19 return} count;\par
84 \}\par
}
}
{\xe \v ShowGraphAsGrid\:graphIO.c}
{\xe \v graphIO.c\:ShowGraphAsGrid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ShowGraphAsGrid ({\b Graph} *  {\i graph})}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 88 \{\par
89     {\cf19 if} (!graph || !graph->head)\par
90     \{\par
91         printf({\cf22 "Grafo vazio.\\n"});\par
92         {\cf19 return} 0;\par
93     \}\par
94 \par
95     {\cf18 char} grid[M][M];\par
96     {\cf19 for} ({\cf18 int} i = 0; i < M; i++)\par
97         {\cf19 for} ({\cf18 int} j = 0; j < M; j++)\par
98             grid[i][j] = {\cf23 '.'};\par
99 \par
100     {\cf18 int} maxX = 0, maxY = 0;\par
101     {\cf18 int} count = 0;\par
102 \par
103     Vertex *v = graph->head;\par
104     {\cf19 while} (v)\par
105     \{\par
106         {\cf18 int} x = (int)(v->coordinateX) - 1;\par
107         {\cf18 int} y = (int)(v->coordinateY) - 1;\par
108 \par
109         {\cf19 if} (x >= 0 && x < M && y >= 0 && y < M)\par
110         \{\par
111             grid[y][x] = v->resonanceFrequency;\par
112             {\cf19 if} (x > maxX)\par
113                 maxX = x;\par
114             {\cf19 if} (y > maxY)\par
115                 maxY = y;\par
116             count++;\par
117         \}\par
118 \par
119         v = v->next;\par
120     \}\par
121 \par
122     printf({\cf22 "\\n--- Grafo em grid ---\\n"});\par
123 \par
124     {\cf19 for} ({\cf18 int} i = 0; i <= maxY; i++)\par
125     \{\par
126         {\cf19 for} ({\cf18 int} j = 0; j <= maxX; j++)\par
127         \{\par
128             printf({\cf22 "%c "}, grid[i][j]);\par
129         \}\par
130         printf({\cf22 "\\n"});\par
131     \}\par
132 \par
133     {\cf19 return} count;\par
134 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia ao ficheiro C:/Users/carlo/Desktop/EDA-Project/graphOp.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/carlo/Desktop/EDA-Project/graphOp.c}
{\xe \v C:/Users/carlo/Desktop/EDA-Project/graphOp.c}
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "graph.h"}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <math.h>}\par
{\f2 #include <stdbool.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b findIntersections} ({\b Graph} *graph, char freqA, char freqB)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v findIntersections\:graphOp.c}
{\xe \v graphOp.c\:findIntersections}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int findIntersections ({\b Graph} *  {\i graph}, char  {\i freqA}, char  {\i freqB})}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15 \{\par
16     printf({\cf22 "\\nProcura de intersec\'E7\'F5es entre %c e %c:\\n"}, freqA, freqB);\par
17 \par
18     Path pathsA[100], pathsB[100]; {\cf20 // Arrays para armazenar caminhos das frequ\'EAncias A e B}\par
19     {\cf18 int} countA = 0, countB = 0;    {\cf20 // Contadores de caminhos \'FAnicos encontrados}\par
20     {\cf18 int} intersectionCount = 0;     {\cf20 // Contador de intersec\'E7\'F5es encontradas}\par
21 \par
22     {\cf20 // Recolha de caminhos entre v\'E9rtices com frequ\'EAncia freqA (sem duplica\'E7\'E3o)}\par
23     Vertex *current = graph->head;\par
24     {\cf19 while} (current != NULL)\par
25     \{\par
26         {\cf19 if} (current->resonanceFrequency == freqA)\par
27         \{\par
28             Adjacency *adj = current->adjacencies;\par
29             {\cf19 while} (adj != NULL)\par
30             \{\par
31                 {\cf20 // Achar o v\'E9rtice de destino com base no \'EDndice}\par
32                 Vertex *dest = graph->head;\par
33                 {\cf19 for} ({\cf18 int} i = 0; i < adj->destinationVertexIndex && dest != NULL; i++)\par
34                     dest = dest->next;\par
35 \par
36                 {\cf20 // Se destino \'E9 v\'E1lido e tem a mesma frequ\'EAncia}\par
37                 {\cf19 if} (dest != NULL && dest->resonanceFrequency == freqA)\par
38                 \{\par
39                     {\cf20 // Verificar se o caminho j\'E1 foi adicionado (em qualquer dire\'E7\'E3o)}\par
40                     {\cf18 bool} exists = {\cf17 false};\par
41                     {\cf19 for} ({\cf18 int} i = 0; i < countA; i++)\par
42                     \{\par
43                         {\cf19 if} ((pathsA[i].start == current && pathsA[i].end == dest) ||\par
44                             (pathsA[i].start == dest && pathsA[i].end == current))\par
45                         \{\par
46                             exists = {\cf17 true};\par
47                             {\cf19 break};\par
48                         \}\par
49                     \}\par
50 \par
51                     {\cf20 // Se n\'E3o existe, adicionar ao array de caminhos}\par
52                     {\cf19 if} (!exists)\par
53                     \{\par
54                         pathsA[countA].start = current;\par
55                         pathsA[countA].end = dest;\par
56                         pathsA[countA].processed = {\cf17 false};\par
57                         countA++;\par
58                     \}\par
59                 \}\par
60                 adj = adj->next;\par
61             \}\par
62         \}\par
63         current = current->next;\par
64     \}\par
65 \par
66     {\cf20 // Recolha de caminhos entre v\'E9rtices com frequ\'EAncia freqB (sem duplica\'E7\'E3o)}\par
67     current = graph->head;\par
68     {\cf19 while} (current != NULL)\par
69     \{\par
70         {\cf19 if} (current->resonanceFrequency == freqB)\par
71         \{\par
72             Adjacency *adj = current->adjacencies;\par
73             {\cf19 while} (adj != NULL)\par
74             \{\par
75                 {\cf20 // Achar o v\'E9rtice de destino com base no \'EDndice}\par
76                 Vertex *dest = graph->head;\par
77                 {\cf19 for} ({\cf18 int} i = 0; i < adj->destinationVertexIndex && dest != NULL; i++)\par
78                     dest = dest->next;\par
79 \par
80                 {\cf19 if} (dest != NULL && dest->resonanceFrequency == freqB)\par
81                 \{\par
82                     {\cf20 // Verificar duplica\'E7\'E3o de caminho}\par
83                     {\cf18 bool} exists = {\cf17 false};\par
84                     {\cf19 for} ({\cf18 int} i = 0; i < countB; i++)\par
85                     \{\par
86                         {\cf19 if} ((pathsB[i].start == current && pathsB[i].end == dest) ||\par
87                             (pathsB[i].start == dest && pathsB[i].end == current))\par
88                         \{\par
89                             exists = {\cf17 true};\par
90                             {\cf19 break};\par
91                         \}\par
92                     \}\par
93 \par
94                     {\cf20 // Adicionar caminho novo}\par
95                     {\cf19 if} (!exists)\par
96                     \{\par
97                         pathsB[countB].start = current;\par
98                         pathsB[countB].end = dest;\par
99                         pathsB[countB].processed = {\cf17 false};\par
100                         countB++;\par
101                     \}\par
102                 \}\par
103                 adj = adj->next;\par
104             \}\par
105         \}\par
106         current = current->next;\par
107     \}\par
108 \par
109     {\cf20 // Verifica\'E7\'E3o de intersec\'E7\'F5es entre os caminhos de freqA e freqB}\par
110     {\cf18 bool} found = {\cf17 false};\par
111     {\cf19 for} ({\cf18 int} i = 0; i < countA; i++)\par
112     \{\par
113         {\cf19 for} ({\cf18 int} j = 0; j < countB; j++)\par
114         \{\par
115             {\cf20 // Apenas verificar caminhos que ainda n\'E3o foram processados}\par
116             {\cf19 if} (!pathsA[i].processed && !pathsB[j].processed)\par
117             \{\par
118                 {\cf20 // Coordenadas do primeiro segmento (freqA)}\par
119                 {\cf18 float} x1 = pathsA[i].start->coordinateX;\par
120                 {\cf18 float} y1 = pathsA[i].start->coordinateY;\par
121                 {\cf18 float} x2 = pathsA[i].end->coordinateX;\par
122                 {\cf18 float} y2 = pathsA[i].end->coordinateY;\par
123 \par
124                 {\cf20 // Coordenadas do segundo segmento (freqB)}\par
125                 {\cf18 float} x3 = pathsB[j].start->coordinateX;\par
126                 {\cf18 float} y3 = pathsB[j].start->coordinateY;\par
127                 {\cf18 float} x4 = pathsB[j].end->coordinateX;\par
128                 {\cf18 float} y4 = pathsB[j].end->coordinateY;\par
129 \par
130                 {\cf20 // C\'E1lculo da intersec\'E7\'E3o usando determinantes (f\'F3rmulas padr\'E3o)}\par
131                 {\cf18 float} denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\par
132 \par
133                 {\cf20 // Se as retas n\'E3o forem paralelas}\par
134                 {\cf19 if} (denom != 0)\par
135                 \{\par
136                     {\cf18 float} ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;\par
137                     {\cf18 float} ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;\par
138 \par
139                     {\cf20 // Verifica se a intersec\'C3\'A7\'C3\'A3o est\'C3\'A1 dentro dos segmentos (0 \'E2\'89\'A4 u \'E2\'89\'A4 1)}\par
140                     {\cf19 if} (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1)\par
141                     \{\par
142                         printf({\cf22 "Intersec\'E7\'E3o encontrada:\\n"});\par
143                         printf({\cf22 "Entre %c(%.0f,%.0f) -> %c(%.0f,%.0f) e "},\par
144                                freqA, x1, y1, freqA, x2, y2);\par
145                         printf({\cf22 "%c(%.0f,%.0f) -> %c(%.0f,%.0f)\\n"},\par
146                                freqB, x3, y3, freqB, x4, y4);\par
147 \par
148                         found = {\cf17 true};\par
149                         intersectionCount++;\par
150 \par
151                         {\cf20 // Marca os caminhos como processados para evitar recontagem}\par
152                         pathsA[i].processed = {\cf17 true};\par
153                         pathsB[j].processed = {\cf17 true};\par
154                     \}\par
155                 \}\par
156             \}\par
157         \}\par
158     \}\par
159 \par
160     {\cf20 // Mensagem caso nenhuma intersec\'E7\'E3o tenha sido encontrada}\par
161     {\cf19 if} (!found)\par
162     \{\par
163         printf({\cf22 "Nenhuma intersec\'E7\'E3o encontrada.\\n"});\par
164     \}\par
165 \par
166     {\cf19 return} intersectionCount;\par
167 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia ao ficheiro C:/Users/carlo/Desktop/EDA-Project/graphSearch.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/carlo/Desktop/EDA-Project/graphSearch.c}
{\xe \v C:/Users/carlo/Desktop/EDA-Project/graphSearch.c}
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "graph.h"}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b visitDFT} ({\b Vertex} *v, bool *visited, {\b Graph} *graph, int index)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b DFT_FromCoordinates} (float x, float y, {\b Graph} *graph)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Enqueue} ({\b Queue} *q, int index)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Dequeue} ({\b Queue} *q)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsQueueEmpty} ({\b Queue} *q)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b BFT_FromCoordinates} (float x, float y, {\b Graph} *graph)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b FindAllPathsUtil} ({\b Vertex} *current, int currentIndex, int endIndex, bool *visited, int *path, int pathIndex, {\b Graph} *graph)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b FindAllPaths} ({\b Graph} *graph, float startX, float startY, float endX, float endY)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v BFT_FromCoordinates\:graphSearch.c}
{\xe \v graphSearch.c\:BFT_FromCoordinates}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int BFT_FromCoordinates (float  {\i x}, float  {\i y}, {\b Graph} *  {\i graph})}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 149 \{\par
150     {\cf19 if} (!graph || !graph->head)\par
151     \{\par
152         printf({\cf22 "Grafo vazio.\\n"});\par
153         {\cf19 return} 0;\par
154     \}\par
155 \par
156     Vertex *v = graph->head;\par
157     {\cf18 int} index = 0;\par
158     {\cf19 while} (v && (v->coordinateX != x || v->coordinateY != y))\par
159     \{\par
160         v = v->next;\par
161         index++;\par
162     \}\par
163 \par
164     {\cf19 if} (!v)\par
165     \{\par
166         printf({\cf22 "Antena n\'E3o encontrada nas coordenadas (%.0f, %.0f)\\n"}, x, y);\par
167         {\cf19 return} 0;\par
168     \}\par
169 \par
170     {\cf18 char} targetResonance = v->resonanceFrequency;\par
171     {\cf18 bool} *visited = ({\cf18 bool} *)calloc(graph->numVertices, {\cf17 sizeof}({\cf18 bool}));\par
172     {\cf19 if} (!visited)\par
173     \{\par
174         printf({\cf22 "Erro de mem\'F3ria.\\n"});\par
175         {\cf19 return} 0;\par
176     \}\par
177 \par
178     Queue q = \{NULL, NULL\};\par
179     Enqueue(&q, index);\par
180     visited[index] = {\cf17 true};\par
181 \par
182     printf({\cf22 "BFT a partir da antena %c (%.0f, %.0f):\\n"}, v->resonanceFrequency, x, y);\par
183     {\cf18 int} verticesVisited = 0;\par
184 \par
185     {\cf19 while} (!IsQueueEmpty(&q))\par
186     \{\par
187         {\cf18 int} currentIndex = Dequeue(&q);\par
188         Vertex *curr = graph->head;\par
189         {\cf19 for} ({\cf18 int} i = 0; curr && i < currentIndex; i++)\par
190             curr = curr->next;\par
191 \par
192         {\cf19 if} (curr)\par
193         \{\par
194             verticesVisited++;\par
195             printf({\cf22 "Antena: %c (%.0f, %.0f)\\n"}, curr->resonanceFrequency, curr->coordinateX, curr->coordinateY);\par
196 \par
197             Adjacency *adj = curr->adjacencies;\par
198             {\cf19 while} (adj)\par
199             \{\par
200                 {\cf19 if} (!visited[adj->destinationVertexIndex])\par
201                 \{\par
202                     Vertex *neighbor = graph->head;\par
203                     {\cf19 for} ({\cf18 int} i = 0; neighbor && i < adj->destinationVertexIndex; i++)\par
204                         neighbor = neighbor->next;\par
205 \par
206                     {\cf19 if} (neighbor && neighbor->resonanceFrequency == targetResonance)\par
207                     \{\par
208                         Enqueue(&q, adj->destinationVertexIndex);\par
209                         visited[adj->destinationVertexIndex] = {\cf17 true};\par
210                     \}\par
211                 \}\par
212                 adj = adj->next;\par
213             \}\par
214         \}\par
215     \}\par
216 \par
217     free(visited);\par
218     printf({\cf22 "Total de v\'E9rtices visitados: %d\\n"}, verticesVisited);\par
219     {\cf19 return} verticesVisited;\par
220 \}\par
}
}
{\xe \v Dequeue\:graphSearch.c}
{\xe \v graphSearch.c\:Dequeue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Dequeue ({\b Queue} *  {\i q})}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 129 \{\par
130     {\cf19 if} (!q->front)\par
131         {\cf19 return} -1;\par
132     QueueNode *temp = q->front;\par
133     {\cf18 int} index = temp->index;\par
134     q->front = temp->next;\par
135     {\cf19 if} (!q->front)\par
136         q->rear = NULL;\par
137     free(temp);\par
138     {\cf19 return} index;\par
139 \}\par
}
}
{\xe \v DFT_FromCoordinates\:graphSearch.c}
{\xe \v graphSearch.c\:DFT_FromCoordinates}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int DFT_FromCoordinates (float  {\i x}, float  {\i y}, {\b Graph} *  {\i graph})}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 64 \{\par
65     {\cf19 if} (!graph || !graph->head)\par
66     \{\par
67         printf({\cf22 "Grafo vazio.\\n"});\par
68         {\cf19 return} 0;\par
69     \}\par
70 \par
71     Vertex *v = graph->head;\par
72     {\cf18 int} index = 0;\par
73     {\cf19 while} (v && (v->coordinateX != x || v->coordinateY != y))\par
74     \{\par
75         v = v->next;\par
76         index++;\par
77     \}\par
78 \par
79     {\cf19 if} (!v)\par
80     \{\par
81         printf({\cf22 "Antena n\'E3o encontrada nas coordenadas (%.0f, %.0f)\\n"}, x, y);\par
82         {\cf19 return} 0;\par
83     \}\par
84 \par
85     {\cf18 bool} *visited = ({\cf18 bool} *)calloc(graph->numVertices, {\cf17 sizeof}({\cf18 bool}));\par
86     {\cf19 if} (!visited)\par
87     \{\par
88         printf({\cf22 "Erro de mem\'F3ria.\\n"});\par
89         {\cf19 return} 0;\par
90     \}\par
91 \par
92     printf({\cf22 "DFT a partir da antena %c (%.0f, %.0f):\\n"}, v->resonanceFrequency, x, y);\par
93     {\cf18 int} verticesVisited = visitDFT(v, visited, graph, index);\par
94     free(visited);\par
95 \par
96     printf({\cf22 "Total de v\'E9rtices visitados: %d\\n"}, verticesVisited);\par
97     {\cf19 return} verticesVisited;\par
98 \}\par
}
}
{\xe \v Enqueue\:graphSearch.c}
{\xe \v graphSearch.c\:Enqueue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Enqueue ({\b Queue} *  {\i q}, int  {\i index})}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 103 \{\par
104     {\cf19 if} (q == NULL)\par
105         {\cf19 return} 0;\par
106 \par
107     QueueNode *newNode = (QueueNode *)malloc({\cf17 sizeof}(QueueNode));\par
108     {\cf19 if} (newNode == NULL)\par
109         {\cf19 return} 0;\par
110 \par
111     newNode->index = index;\par
112     newNode->next = NULL;\par
113 \par
114     {\cf19 if} (q->rear == NULL)\par
115     \{\par
116         q->front = q->rear = newNode;\par
117     \}\par
118     {\cf19 else}\par
119     \{\par
120         q->rear->next = newNode;\par
121         q->rear = newNode;\par
122     \}\par
123 \par
124     {\cf19 return} 1;\par
125 \}\par
}
}
{\xe \v FindAllPaths\:graphSearch.c}
{\xe \v graphSearch.c\:FindAllPaths}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int FindAllPaths ({\b Graph} *  {\i graph}, float  {\i startX}, float  {\i startY}, float  {\i endX}, float  {\i endY})}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 288 \{\par
289     {\cf19 if} (!graph || !graph->head)\par
290     \{\par
291         printf({\cf22 "Grafo vazio.\\n"});\par
292         {\cf19 return} 0;\par
293     \}\par
294 \par
295     Vertex *start = graph->head;\par
296     Vertex *end = graph->head;\par
297     {\cf18 int} startIndex = 0, endIndex = 0;\par
298     {\cf18 bool} startFound = {\cf17 false}, endFound = {\cf17 false};\par
299 \par
300     {\cf20 // Procura os v\'E9rtices correspondentes \'E0s coordenadas de in\'EDcio e fim}\par
301     Vertex *current = graph->head;\par
302     {\cf18 int} index = 0;\par
303     {\cf19 while} (current)\par
304     \{\par
305         {\cf19 if} (!startFound && current->coordinateX == startX && current->coordinateY == startY)\par
306         \{\par
307             start = current;\par
308             startIndex = index;\par
309             startFound = {\cf17 true};\par
310         \}\par
311 \par
312         {\cf19 if} (!endFound && current->coordinateX == endX && current->coordinateY == endY)\par
313         \{\par
314             end = current;\par
315             endIndex = index;\par
316             endFound = {\cf17 true};\par
317         \}\par
318 \par
319         current = current->next;\par
320         index++;\par
321     \}\par
322 \par
323     {\cf20 // Verifica se ambos os v\'E9rtices foram encontrados}\par
324     {\cf19 if} (!startFound || !endFound)\par
325     \{\par
326         printf({\cf22 "Antenas inicial ou final n\'E3o encontradas.\\n"});\par
327         {\cf19 return} 0;\par
328     \}\par
329 \par
330     {\cf20 // Verifica se ambos os v\'E9rtices possuem a mesma frequ\'EAncia de resson\'E2ncia}\par
331     {\cf19 if} (start->resonanceFrequency != end->resonanceFrequency)\par
332     \{\par
333         printf({\cf22 "As antenas n\'E3o t\'EAm a mesma frequ\'EAncia.\\n"});\par
334         {\cf19 return} 0;\par
335     \}\par
336 \par
337     {\cf20 // Aloca mem\'F3ria para controlar os v\'E9rtices visitados e o caminho atual}\par
338     {\cf18 bool} *visited = ({\cf18 bool} *)calloc(graph->numVertices, {\cf17 sizeof}({\cf18 bool}));\par
339     {\cf18 int} *path = ({\cf18 int} *)malloc(graph->numVertices * {\cf17 sizeof}({\cf18 int}));\par
340 \par
341     {\cf20 // Mostra as informa\'E7\'F5es de in\'EDcio e fim}\par
342     printf({\cf22 "Todos os caminhos de %c(%.0f,%.0f) a %c(%.0f,%.0f):\\n"},\par
343            start->resonanceFrequency, startX, startY,\par
344            end->resonanceFrequency, endX, endY);\par
345 \par
346     {\cf20 // Inicia a procura pelos caminhos}\par
347     {\cf18 int} totalPaths = FindAllPathsUtil(start, startIndex, endIndex, visited, path, 0, graph);\par
348 \par
349     {\cf20 // Mostra o n\'FAmero total de caminhos encontrados}\par
350     printf({\cf22 "Total de caminhos encontrados: %d\\n"}, totalPaths);\par
351 \par
352     {\cf20 // Liberta mem\'F3ria alocada}\par
353     free(visited);\par
354     free(path);\par
355     {\cf19 return} totalPaths;\par
356 \}\par
}
}
{\xe \v FindAllPathsUtil\:graphSearch.c}
{\xe \v graphSearch.c\:FindAllPathsUtil}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int FindAllPathsUtil ({\b Vertex} *  {\i current}, int  {\i currentIndex}, int  {\i endIndex}, bool *  {\i visited}, int *  {\i path}, int  {\i pathIndex}, {\b Graph} *  {\i graph})}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 225 \{\par
226     {\cf18 int} pathCount = 0;\par
227 \par
228     {\cf20 // Marca o v\'E9rtice atual como visitado}\par
229     visited[currentIndex] = {\cf17 true};\par
230 \par
231     {\cf20 // Adiciona o \'EDndice atual ao caminho}\par
232     path[pathIndex] = currentIndex;\par
233     pathIndex++;\par
234 \par
235     {\cf20 // Se o v\'E9rtice atual \'E9 o destino, mostra o caminho completo}\par
236     {\cf19 if} (currentIndex == endIndex)\par
237     \{\par
238         pathCount++;\par
239         {\cf19 for} ({\cf18 int} i = 0; i < pathIndex; i++)\par
240         \{\par
241             {\cf20 // Navega at\'E9 o v\'E9rtice correspondente ao \'EDndice armazenado}\par
242             Vertex *v = graph->head;\par
243             {\cf19 for} ({\cf18 int} j = 0; j < path[i]; j++)\par
244                 v = v->next;\par
245 \par
246             {\cf20 // Mostra o v\'E9rtice no formato: letra(frequ\'EAncia)(x,y)}\par
247             printf({\cf22 "%c(%.0f,%.0f)"}, v->resonanceFrequency, v->coordinateX, v->coordinateY);\par
248 \par
249             {\cf19 if} (i < pathIndex - 1)\par
250                 printf({\cf22 " -> "});\par
251         \}\par
252         printf({\cf22 "\\n"});\par
253     \}\par
254     {\cf19 else}\par
255     \{\par
256         {\cf20 // Percorre todas as adjac\'EAncias do v\'E9rtice atual}\par
257         Adjacency *adj = current->adjacencies;\par
258         {\cf19 while} (adj)\par
259         \{\par
260             {\cf20 // Se o v\'E9rtice destino ainda n\'E3o foi visitado}\par
261             {\cf19 if} (!visited[adj->destinationVertexIndex])\par
262             \{\par
263                 {\cf20 // Encontra o pr\'F3ximo v\'E9rtice com base no \'EDndice de destino}\par
264                 Vertex *next = graph->head;\par
265                 {\cf19 for} ({\cf18 int} i = 0; i < adj->destinationVertexIndex; i++)\par
266                     next = next->next;\par
267 \par
268                 {\cf20 // S\'F3 continua a procura se a frequ\'EAncia for a mesma}\par
269                 {\cf19 if} (next && next->resonanceFrequency == current->resonanceFrequency)\par
270                 \{\par
271                     {\cf20 // Chamada recursiva para continuar a procura a partir do v\'E9rtice adjacente}\par
272                     pathCount += FindAllPathsUtil(next, adj->destinationVertexIndex, endIndex, visited, path, pathIndex, graph);\par
273                 \}\par
274             \}\par
275             {\cf20 // Avan\'E7a para a pr\'F3xima adjac\'EAncia}\par
276             adj = adj->next;\par
277         \}\par
278     \}\par
279 \par
280     {\cf20 // Backtracking: desmarca o v\'E9rtice como visitado e retrocede o caminho}\par
281     visited[currentIndex] = {\cf17 false};\par
282     pathIndex--;\par
283     {\cf19 return} pathCount;\par
284 \}\par
}
}
{\xe \v IsQueueEmpty\:graphSearch.c}
{\xe \v graphSearch.c\:IsQueueEmpty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool IsQueueEmpty ({\b Queue} *  {\i q})}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 143 \{\par
144     {\cf19 return} q->front == NULL;\par
145 \}\par
}
}
{\xe \v visitDFT\:graphSearch.c}
{\xe \v graphSearch.c\:visitDFT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int visitDFT ({\b Vertex} *  {\i v}, bool *  {\i visited}, {\b Graph} *  {\i graph}, int  {\i index})}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14 \{\par
15     {\cf19 if} (!v)\par
16         {\cf19 return} 0;\par
17 \par
18     {\cf18 int} count = 1; {\cf20 // Conta o v\'E9rtice atual}\par
19     visited[index] = {\cf17 true};\par
20     printf({\cf22 "Antena: %c (%.0f, %.0f)\\n"}, v->resonanceFrequency, v->coordinateX, v->coordinateY);\par
21 \par
22     {\cf20 // Criar uma lista tempor\'E1ria de adjac\'EAncias}\par
23     Adjacency *adjList = NULL;\par
24     Adjacency *adj = v->adjacencies;\par
25 \par
26     {\cf20 // Copiar as adjac\'EAncias para uma lista tempor\'E1ria}\par
27     {\cf19 while} (adj)\par
28     \{\par
29         Adjacency *newAdj = CreateAdjacency(adj->distance, adj->resonanceFrequency, adj->destinationVertexIndex);\par
30         newAdj->next = adjList;\par
31         adjList = newAdj;\par
32         adj = adj->next;\par
33     \}\par
34 \par
35     {\cf20 // Visitar cada adjac\'EAncia}\par
36     adj = adjList;\par
37     {\cf19 while} (adj)\par
38     \{\par
39         {\cf19 if} (!visited[adj->destinationVertexIndex])\par
40         \{\par
41             Vertex *next = graph->head;\par
42             {\cf19 for} ({\cf18 int} i = 0; next && i < adj->destinationVertexIndex; i++)\par
43                 next = next->next;\par
44 \par
45             {\cf19 if} (next && next->resonanceFrequency == v->resonanceFrequency)\par
46                 count += visitDFT(next, visited, graph, adj->destinationVertexIndex);\par
47         \}\par
48         adj = adj->next;\par
49     \}\par
50 \par
51     {\cf20 // Libertar a lista tempor\'E1ria}\par
52     {\cf19 while} (adjList)\par
53     \{\par
54         Adjacency *temp = adjList;\par
55         adjList = adjList->next;\par
56         free(temp);\par
57     \}\par
58 \par
59     {\cf19 return} count;\par
60 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia ao ficheiro C:/Users/carlo/Desktop/EDA-Project/gridUtils.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/carlo/Desktop/EDA-Project/gridUtils.c}
{\xe \v C:/Users/carlo/Desktop/EDA-Project/gridUtils.c}
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include "gridUtils.h"}\par
{\f2 #include "aerial.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getGridSize} ({\b ED} *list, int *xMax, int *yMax)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b showAerialList} ({\b ED} *list)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v getGridSize\:gridUtils.c}
{\xe \v gridUtils.c\:getGridSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int getGridSize ({\b ED} *  {\i list}, int *  {\i xMax}, int *  {\i yMax})}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14 \{\par
15     *xMax = 0;\par
16     *yMax = 0;\par
17     ED *aux = list;\par
18 \par
19     {\cf19 while} (aux != NULL)\par
20     \{\par
21         {\cf19 if} (aux->coordinateX > *xMax)\par
22         \{\par
23             *xMax = aux->coordinateX;\par
24         \}\par
25         {\cf19 if} (aux->coordinateY > *yMax)\par
26         \{\par
27             *yMax = aux->coordinateY;\par
28         \}\par
29         aux = aux->next;\par
30     \}\par
31     {\cf19 return} 0;\par
32 \}\par
}
}
{\xe \v showAerialList\:gridUtils.c}
{\xe \v gridUtils.c\:showAerialList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int showAerialList ({\b ED} *  {\i list})}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 36 \{\par
37     {\cf18 int} xMax, yMax;\par
38     getGridSize(list, &xMax, &yMax);\par
39 \par
40     {\cf18 char} grid[yMax][xMax];\par
41 \par
42     {\cf19 for} ({\cf18 int} y = 0; y < yMax; y++)\par
43     \{\par
44         {\cf19 for} ({\cf18 int} x = 0; x < xMax; x++)\par
45         \{\par
46             grid[y][x] = {\cf23 '.'};\par
47         \}\par
48     \}\par
49 \par
50     ED *aux = list;\par
51     {\cf19 while} (aux != NULL)\par
52     \{\par
53         {\cf19 if} (aux->coordinateX <= xMax && aux->coordinateY <= yMax && aux->coordinateX >= 1 && aux->coordinateY >= 1)\par
54         \{\par
55             grid[aux->coordinateY - 1][aux->coordinateX - 1] = aux->resonanceFrequency;\par
56         \}\par
57         aux = aux->next;\par
58     \}\par
59 \par
60     printf({\cf22 "\\n\\tAntenas:\\n"});\par
61     {\cf19 for} ({\cf18 int} y = 0; y < yMax; y++)\par
62     \{\par
63         printf({\cf22 "\\t"});\par
64         {\cf19 for} ({\cf18 int} x = 0; x < xMax; x++)\par
65         \{\par
66             printf({\cf22 "%c "}, grid[y][x]);\par
67         \}\par
68         printf({\cf22 "\\n"});\par
69     \}\par
70     printf({\cf22 "\\n"});\par
71     {\cf19 return} 0;\par
72 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia ao ficheiro C:/Users/carlo/Desktop/EDA-Project/gridUtils.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/carlo/Desktop/EDA-Project/gridUtils.h}
{\xe \v C:/Users/carlo/Desktop/EDA-Project/gridUtils.h}
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "aerial.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getGridSize} ({\b ED} *list, int *xMax, int *yMax)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b showAerialList} ({\b ED} *{\b ED})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v getGridSize\:gridUtils.h}
{\xe \v gridUtils.h\:getGridSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int getGridSize ({\b ED} *  {\i list}, int *  {\i xMax}, int *  {\i yMax})}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14 \{\par
15     *xMax = 0;\par
16     *yMax = 0;\par
17     ED *aux = list;\par
18 \par
19     {\cf19 while} (aux != NULL)\par
20     \{\par
21         {\cf19 if} (aux->coordinateX > *xMax)\par
22         \{\par
23             *xMax = aux->coordinateX;\par
24         \}\par
25         {\cf19 if} (aux->coordinateY > *yMax)\par
26         \{\par
27             *yMax = aux->coordinateY;\par
28         \}\par
29         aux = aux->next;\par
30     \}\par
31     {\cf19 return} 0;\par
32 \}\par
}
}
{\xe \v showAerialList\:gridUtils.h}
{\xe \v gridUtils.h\:showAerialList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int showAerialList ({\b ED} *  {\i ED})}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 36 \{\par
37     {\cf18 int} xMax, yMax;\par
38     getGridSize(list, &xMax, &yMax);\par
39 \par
40     {\cf18 char} grid[yMax][xMax];\par
41 \par
42     {\cf19 for} ({\cf18 int} y = 0; y < yMax; y++)\par
43     \{\par
44         {\cf19 for} ({\cf18 int} x = 0; x < xMax; x++)\par
45         \{\par
46             grid[y][x] = {\cf23 '.'};\par
47         \}\par
48     \}\par
49 \par
50     ED *aux = list;\par
51     {\cf19 while} (aux != NULL)\par
52     \{\par
53         {\cf19 if} (aux->coordinateX <= xMax && aux->coordinateY <= yMax && aux->coordinateX >= 1 && aux->coordinateY >= 1)\par
54         \{\par
55             grid[aux->coordinateY - 1][aux->coordinateX - 1] = aux->resonanceFrequency;\par
56         \}\par
57         aux = aux->next;\par
58     \}\par
59 \par
60     printf({\cf22 "\\n\\tAntenas:\\n"});\par
61     {\cf19 for} ({\cf18 int} y = 0; y < yMax; y++)\par
62     \{\par
63         printf({\cf22 "\\t"});\par
64         {\cf19 for} ({\cf18 int} x = 0; x < xMax; x++)\par
65         \{\par
66             printf({\cf22 "%c "}, grid[y][x]);\par
67         \}\par
68         printf({\cf22 "\\n"});\par
69     \}\par
70     printf({\cf22 "\\n"});\par
71     {\cf19 return} 0;\par
72 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gridUtils.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/carlo/Desktop/EDA-Project/gridUtils.h}
{\xe \v C:/Users/carlo/Desktop/EDA-Project/gridUtils.h}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
Ir para a documenta\'E7\'E3o deste ficheiro.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 // File: gridUtils.h}\par
2 {\cf20 // Desc: Declara\'E7\'F5es para fun\'E7\'F5es relacionadas ao grid}\par
3 {\cf20 // Auth: Carlos Barreiro}\par
4 {\cf20 // Mail: a20360@alunos.ipca.pt}\par
5 {\cf20 // Date: 2025/03}\par
6 \par
7 {\cf21 #ifndef GRID_UTILS_H}\par
8 {\cf21 #define GRID_UTILS_H}\par
9 \par
10 {\cf21 #include "aerial.h"} {\cf20 // Necess\'E1rio para a defini\'E7\'E3o de ED}\par
11 \par
12 {\cf20 // Fun\'E7\'E3o para saber o tamanho do grid (/tabela)}\par
13 {\cf18 int} getGridSize(ED *list, {\cf18 int} *xMax, {\cf18 int} *yMax);\par
14 \par
15 {\cf20 // Fun\'E7\'E3o para imprimir a lista de antenas}\par
16 {\cf18 int} showAerialList(ED *ED);\par
17 \par
18 {\cf21 #endif }{\cf20 // GRID_UTILS_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia ao ficheiro C:/Users/carlo/Desktop/EDA-Project/interference.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/carlo/Desktop/EDA-Project/interference.c}
{\xe \v C:/Users/carlo/Desktop/EDA-Project/interference.c}
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <math.h>}\par
{\f2 #include "interference.h"}\par
{\f2 #include "aerial.h"}\par
{\f2 #include "gridUtils.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b interferencesED} ({\b ED} *list)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v interferencesED\:interference.c}
{\xe \v interference.c\:interferencesED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int interferencesED ({\b ED} *  {\i list})}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15 \{\par
16     ED *interferencesED = NULL;\par
17     {\cf18 int} hasDuplicates = 0;\par
18 \par
19     ED *current = list;\par
20     {\cf19 while} (current != NULL)\par
21     \{\par
22         ED *temp = current->next;\par
23         {\cf19 while} (temp != NULL)\par
24         \{\par
25             {\cf19 if} (temp->resonanceFrequency == current->resonanceFrequency)\par
26             \{\par
27                 hasDuplicates = 1;\par
28                 {\cf19 break};\par
29             \}\par
30             temp = temp->next;\par
31         \}\par
32         {\cf19 if} (hasDuplicates)\par
33             {\cf19 break};\par
34         current = current->next;\par
35     \}\par
36 \par
37     {\cf19 if} (!hasDuplicates)\par
38     \{\par
39         printf({\cf22 "N\'E3o h\'E1 frequ\'EAncias de resson\'E2ncia repetidas.\\n"});\par
40         showAerialList(list);\par
41         {\cf19 return} 0;\par
42     \}\par
43 \par
44     current = list;\par
45     {\cf19 while} (current != NULL)\par
46     \{\par
47         interferencesED = insertAerialEnd(interferencesED, current->resonanceFrequency, current->coordinateX, current->coordinateY);\par
48         current = current->next;\par
49     \}\par
50 \par
51     current = list;\par
52     {\cf19 while} (current != NULL)\par
53     \{\par
54         ED *other = current->next;\par
55         {\cf19 while} (other != NULL)\par
56         \{\par
57             {\cf19 if} (current->resonanceFrequency == other->resonanceFrequency)\par
58             \{\par
59                 {\cf18 int} diffX = other->coordinateX - current->coordinateX;\par
60                 {\cf18 int} diffY = other->coordinateY - current->coordinateY;\par
61 \par
62                 {\cf19 if} (abs(diffX) >= 2 || abs(diffY) >= 2)\par
63                 \{\par
64                     {\cf18 int} interferenceX1 = current->coordinateX - diffX;\par
65                     {\cf18 int} interferenceY1 = current->coordinateY - diffY;\par
66 \par
67                     {\cf19 if} (interferenceX1 > 0 && interferenceY1 > 0)\par
68                     \{\par
69                         {\cf18 int} isAerial = 0;\par
70                         ED *check = list;\par
71                         {\cf19 while} (check != NULL)\par
72                         \{\par
73                             {\cf19 if} (check->coordinateX == interferenceX1 && check->coordinateY == interferenceY1)\par
74                             \{\par
75                                 isAerial = 1;\par
76                                 {\cf19 break};\par
77                             \}\par
78                             check = check->next;\par
79                         \}\par
80 \par
81                         {\cf19 if} (!isAerial)\par
82                         \{\par
83                             interferencesED = insertAerialEnd(interferencesED, {\cf23 '#'}, interferenceX1, interferenceY1);\par
84                         \}\par
85                     \}\par
86 \par
87                     {\cf18 int} interferenceX2 = other->coordinateX + diffX;\par
88                     {\cf18 int} interferenceY2 = other->coordinateY + diffY;\par
89 \par
90                     {\cf19 if} (interferenceX2 > 0 && interferenceY2 > 0)\par
91                     \{\par
92                         {\cf18 int} isAerial = 0;\par
93                         ED *check = list;\par
94                         {\cf19 while} (check != NULL)\par
95                         \{\par
96                             {\cf19 if} (check->coordinateX == interferenceX2 && check->coordinateY == interferenceY2)\par
97                             \{\par
98                                 isAerial = 1;\par
99                                 {\cf19 break};\par
100                             \}\par
101                             check = check->next;\par
102                         \}\par
103 \par
104                         {\cf19 if} (!isAerial)\par
105                         \{\par
106                             interferencesED = insertAerialEnd(interferencesED, {\cf23 '#'}, interferenceX2, interferenceY2);\par
107                         \}\par
108                     \}\par
109                 \}\par
110             \}\par
111             other = other->next;\par
112         \}\par
113         current = current->next;\par
114     \}\par
115 \par
116     printf({\cf22 "\\nInterfer\'EAncias calculadas:\\n"});\par
117     showAerialList(interferencesED);\par
118 \par
119     {\cf19 while} (interferencesED != NULL)\par
120     \{\par
121         ED *temp = interferencesED;\par
122         interferencesED = interferencesED->next;\par
123         free(temp);\par
124     \}\par
125     {\cf19 return} 0;\par
126 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia ao ficheiro C:/Users/carlo/Desktop/EDA-Project/interference.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/carlo/Desktop/EDA-Project/interference.h}
{\xe \v C:/Users/carlo/Desktop/EDA-Project/interference.h}
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "aerial.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b interferencesED} ({\b ED} *list)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v interferencesED\:interference.h}
{\xe \v interference.h\:interferencesED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int interferencesED ({\b ED} *  {\i list})}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15 \{\par
16     ED *interferencesED = NULL;\par
17     {\cf18 int} hasDuplicates = 0;\par
18 \par
19     ED *current = list;\par
20     {\cf19 while} (current != NULL)\par
21     \{\par
22         ED *temp = current->next;\par
23         {\cf19 while} (temp != NULL)\par
24         \{\par
25             {\cf19 if} (temp->resonanceFrequency == current->resonanceFrequency)\par
26             \{\par
27                 hasDuplicates = 1;\par
28                 {\cf19 break};\par
29             \}\par
30             temp = temp->next;\par
31         \}\par
32         {\cf19 if} (hasDuplicates)\par
33             {\cf19 break};\par
34         current = current->next;\par
35     \}\par
36 \par
37     {\cf19 if} (!hasDuplicates)\par
38     \{\par
39         printf({\cf22 "N\'E3o h\'E1 frequ\'EAncias de resson\'E2ncia repetidas.\\n"});\par
40         showAerialList(list);\par
41         {\cf19 return} 0;\par
42     \}\par
43 \par
44     current = list;\par
45     {\cf19 while} (current != NULL)\par
46     \{\par
47         interferencesED = insertAerialEnd(interferencesED, current->resonanceFrequency, current->coordinateX, current->coordinateY);\par
48         current = current->next;\par
49     \}\par
50 \par
51     current = list;\par
52     {\cf19 while} (current != NULL)\par
53     \{\par
54         ED *other = current->next;\par
55         {\cf19 while} (other != NULL)\par
56         \{\par
57             {\cf19 if} (current->resonanceFrequency == other->resonanceFrequency)\par
58             \{\par
59                 {\cf18 int} diffX = other->coordinateX - current->coordinateX;\par
60                 {\cf18 int} diffY = other->coordinateY - current->coordinateY;\par
61 \par
62                 {\cf19 if} (abs(diffX) >= 2 || abs(diffY) >= 2)\par
63                 \{\par
64                     {\cf18 int} interferenceX1 = current->coordinateX - diffX;\par
65                     {\cf18 int} interferenceY1 = current->coordinateY - diffY;\par
66 \par
67                     {\cf19 if} (interferenceX1 > 0 && interferenceY1 > 0)\par
68                     \{\par
69                         {\cf18 int} isAerial = 0;\par
70                         ED *check = list;\par
71                         {\cf19 while} (check != NULL)\par
72                         \{\par
73                             {\cf19 if} (check->coordinateX == interferenceX1 && check->coordinateY == interferenceY1)\par
74                             \{\par
75                                 isAerial = 1;\par
76                                 {\cf19 break};\par
77                             \}\par
78                             check = check->next;\par
79                         \}\par
80 \par
81                         {\cf19 if} (!isAerial)\par
82                         \{\par
83                             interferencesED = insertAerialEnd(interferencesED, {\cf23 '#'}, interferenceX1, interferenceY1);\par
84                         \}\par
85                     \}\par
86 \par
87                     {\cf18 int} interferenceX2 = other->coordinateX + diffX;\par
88                     {\cf18 int} interferenceY2 = other->coordinateY + diffY;\par
89 \par
90                     {\cf19 if} (interferenceX2 > 0 && interferenceY2 > 0)\par
91                     \{\par
92                         {\cf18 int} isAerial = 0;\par
93                         ED *check = list;\par
94                         {\cf19 while} (check != NULL)\par
95                         \{\par
96                             {\cf19 if} (check->coordinateX == interferenceX2 && check->coordinateY == interferenceY2)\par
97                             \{\par
98                                 isAerial = 1;\par
99                                 {\cf19 break};\par
100                             \}\par
101                             check = check->next;\par
102                         \}\par
103 \par
104                         {\cf19 if} (!isAerial)\par
105                         \{\par
106                             interferencesED = insertAerialEnd(interferencesED, {\cf23 '#'}, interferenceX2, interferenceY2);\par
107                         \}\par
108                     \}\par
109                 \}\par
110             \}\par
111             other = other->next;\par
112         \}\par
113         current = current->next;\par
114     \}\par
115 \par
116     printf({\cf22 "\\nInterfer\'EAncias calculadas:\\n"});\par
117     showAerialList(interferencesED);\par
118 \par
119     {\cf19 while} (interferencesED != NULL)\par
120     \{\par
121         ED *temp = interferencesED;\par
122         interferencesED = interferencesED->next;\par
123         free(temp);\par
124     \}\par
125     {\cf19 return} 0;\par
126 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
interference.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/carlo/Desktop/EDA-Project/interference.h}
{\xe \v C:/Users/carlo/Desktop/EDA-Project/interference.h}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
Ir para a documenta\'E7\'E3o deste ficheiro.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 // File: interference.h}\par
2 {\cf20 // Desc: Declara\'E7\'F5es para fun\'E7\'F5es de c\'E1lculo das interfer\'EAncias}\par
3 {\cf20 // Auth: Carlos Barreiro}\par
4 {\cf20 // Mail: a20360@alunos.ipca.pt}\par
5 {\cf20 // Date: 2025/03}\par
6 \par
7 {\cf21 #ifndef INTERFERENCE_H}\par
8 {\cf21 #define INTERFERENCE_H}\par
9 \par
10 {\cf21 #include "aerial.h"} {\cf20 // Necess\'E1rio para a defini\'E7\'E3o de ED}\par
11 \par
12 {\cf20 // Fun\'E7\'E3o para calcular e mostrar as interfer\'EAncias}\par
13 {\cf18 int} interferencesED(ED *list);\par
14 \par
15 {\cf21 #endif }{\cf20 // INTERFERENCE_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia ao ficheiro C:/Users/carlo/Desktop/EDA-Project/main.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/carlo/Desktop/EDA-Project/main.c}
{\xe \v C:/Users/carlo/Desktop/EDA-Project/main.c}
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <windows.h>}\par
{\f2 #include "aerial.h"}\par
{\f2 #include "fileUtils.h"}\par
{\f2 #include "gridUtils.h"}\par
{\f2 #include "interference.h"}\par
{\f2 #include "graph.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b runPart1} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b runPart2} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v main\:main.c}
{\xe \v main.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 269 \{\par
270     SetConsoleOutputCP(65001); {\cf20 // Define a codifica\'E7\'E3o do terminal para UTF-8}\par
271 \par
272     {\cf18 int} partChoice;\par
273 \par
274     printf({\cf22 "\\nProjecto de EDA\\n"});\par
275     printf({\cf22 "Escolha a fase que deseja executar:\\n"});\par
276     printf({\cf22 "1 - Fase 1: Gest\'E3o de antenas\\n"});\par
277     printf({\cf22 "2 - Fase 2: Teste de grafo\\n"});\par
278     printf({\cf22 "Escolha: "});\par
279     scanf({\cf22 "%d"}, &partChoice);\par
280 \par
281     {\cf19 switch} (partChoice)\par
282     \{\par
283     {\cf19 case} 0:\par
284         printf({\cf22 "\\nA encerrar...\\n"});\par
285         {\cf19 break};\par
286 \par
287     {\cf19 case} 1: {\cf20 // Fase 1}\par
288         runPart1();\par
289         {\cf19 break};\par
290 \par
291     {\cf19 case} 2: {\cf20 // Fase 2}\par
292         runPart2();\par
293         {\cf19 break};\par
294 \par
295     {\cf19 default}:\par
296         printf({\cf22 "\\nOp\'E7\'E3o inv\'E1lida! A encerrar...\\n"});\par
297         {\cf19 break};\par
298     \}\par
299 \par
300     {\cf19 return} 0;\par
301 \}\par
}
}
{\xe \v runPart1\:main.c}
{\xe \v main.c\:runPart1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int runPart1 ()}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18 \{\par
19     {\cf18 int} choice, coordinateX, coordinateY;\par
20     {\cf18 char} resonanceFrequency, loadChoice, retryChoice;\par
21     ED *list = NULL;\par
22 \par
23     {\cf20 // Carregar o ficheiro ou n\'E3o}\par
24     printf({\cf22 "Carregar a posi\'E7\'E3o das antenas de um ficheiro? (s/n): "});\par
25     scanf({\cf22 " %c"}, &loadChoice);\par
26 \par
27     {\cf19 if} (loadChoice == {\cf23 's'} || loadChoice == {\cf23 'S'})\par
28     \{\par
29         {\cf18 char} filename[100];\par
30         {\cf19 do}\par
31         \{\par
32             printf({\cf22 "Qual o nome do ficheiro: "});\par
33             scanf({\cf22 "%s"}, filename);\par
34 \par
35             list = loadAerialsFromFile(list, filename);\par
36 \par
37             {\cf19 if} (list == NULL)\par
38             \{\par
39                 printf({\cf22 "Erro ao abrir o ficheiro %s. Deseja tentar novamente? (s/n): "}, filename);\par
40                 scanf({\cf22 " %c"}, &retryChoice);\par
41                 {\cf19 if} (retryChoice == {\cf23 'n'} || retryChoice == {\cf23 'N'})\par
42                 \{\par
43                     {\cf19 break};\par
44                 \}\par
45             \}\par
46             {\cf19 else}\par
47             \{\par
48                 {\cf19 break};\par
49             \}\par
50         \} {\cf19 while} (1);\par
51     \}\par
52     {\cf19 else}\par
53     \{\par
54         printf({\cf22 "A criar uma nova lista vazia...\\n"});\par
55     \}\par
56 \par
57     {\cf19 do}\par
58     \{\par
59         printf({\cf22 "\\n\\t0 - Sair\\n\\t1 - Inserir na lista\\n\\t2 - Mostrar a lista\\n\\t3 - Remover da lista\\n\\t4 - Mostrar interfer\'EAncias\\n\\tEscolha uma op\'E7\'E3o: "});\par
60         scanf({\cf22 "%d"}, &choice);\par
61 \par
62         {\cf19 switch} (choice)\par
63         \{\par
64         {\cf19 case} 0:\par
65             printf({\cf22 "\\nA encerrar o programa...\\n"});\par
66             {\cf19 break};\par
67 \par
68         {\cf19 case} 1:\par
69             printf({\cf22 "Insira a frequ\'EAncia de resson\'E2ncia da antena: "});\par
70             scanf({\cf22 " %c"}, &resonanceFrequency);\par
71             printf({\cf22 "Insira a coordenada X da antena: "});\par
72             scanf({\cf22 "%d"}, &coordinateX);\par
73             printf({\cf22 "Insira a coordenada Y da antena: "});\par
74             scanf({\cf22 "%d"}, &coordinateY);\par
75             list = insertAerialEnd(list, resonanceFrequency, coordinateX, coordinateY);\par
76             {\cf19 break};\par
77 \par
78         {\cf19 case} 2:\par
79             showAerialList(list);\par
80             {\cf19 break};\par
81 \par
82         {\cf19 case} 3:\par
83             printf({\cf22 "Insira a coordenada X da antena a remover: "});\par
84             scanf({\cf22 "%d"}, &coordinateX);\par
85             printf({\cf22 "Insira a coordenada Y da antena a remover: "});\par
86             scanf({\cf22 "%d"}, &coordinateY);\par
87             list = removeAerial(list, coordinateX, coordinateY);\par
88             {\cf19 break};\par
89 \par
90         {\cf19 case} 4:\par
91             interferencesED(list);\par
92             {\cf19 break};\par
93 \par
94         {\cf19 default}:\par
95             printf({\cf22 "\\nOp\'E7\'E3o inv\'E1lida!\\n"});\par
96             {\cf19 break};\par
97         \}\par
98     \} {\cf19 while} (choice != 0);\par
99     {\cf19 return} 1;\par
100 \}\par
}
}
{\xe \v runPart2\:main.c}
{\xe \v main.c\:runPart2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int runPart2 ()}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 104 \{\par
105     {\cf20 // Inicializa o grafo}\par
106     Graph *graph = (Graph *)malloc({\cf17 sizeof}(Graph));\par
107     {\cf19 if} (graph == NULL)\par
108     \{\par
109         printf({\cf22 "Erro: Falha ao alocar mem\'F3ria para o grafo.\\n"});\par
110         {\cf19 return} 0;\par
111     \}\par
112 \par
113     graph->numVertices = 0; {\cf20 // Inicializa o n\'FAmero de v\'E9rtices}\par
114     graph->head = NULL;     {\cf20 // Inicializa a in\'EDcio do grafo}\par
115 \par
116     {\cf18 int} choice, result;\par
117     {\cf18 char} resonance;\par
118     {\cf18 float} x, y;\par
119     {\cf18 char} fileName[100];\par
120 \par
121     {\cf19 do}\par
122     \{\par
123         printf({\cf22 "\\n--- Menu ---\\n"});\par
124         printf({\cf22 "1. Adicionar antena\\n"});\par
125         printf({\cf22 "2. Mostrar o grafo\\n"});\par
126         printf({\cf22 "3. Mostrar grafo atraves de grid\\n"});\par
127         printf({\cf22 "4. Carregar ficheiro\\n"});\par
128         printf({\cf22 "5. DFT\\n"});\par
129         printf({\cf22 "6. BFT\\n"});\par
130         printf({\cf22 "7. Mostrar todos os caminhos entre duas antenas\\n"});\par
131         printf({\cf22 "8. Mostrar interse\'E7\'F5es entre duas frequ\'EAncias\\n"});\par
132         printf({\cf22 "0. Sair\\n"});\par
133         printf({\cf22 "Escolha: "});\par
134         scanf({\cf22 "%d"}, &choice);\par
135 \par
136         {\cf19 switch} (choice)\par
137         \{\par
138         {\cf19 case} 1: {\cf20 // Adicionar antena manualmente}\par
139             printf({\cf22 "Frequ\'EAncia da antena: "});\par
140             scanf({\cf22 " %c"}, &resonance);\par
141             printf({\cf22 "Coordenada X: "});\par
142             scanf({\cf22 "%f"}, &x);\par
143             printf({\cf22 "Coordenada Y: "});\par
144             scanf({\cf22 "%f"}, &y);\par
145 \par
146             \{\par
147                 Vertex *v = CreateVertex(resonance, x, y);\par
148                 {\cf18 int} res;\par
149                 graph->head = InsertVertex(v, graph->head, &res);\par
150                 {\cf19 if} (res)\par
151                 \{\par
152                     graph->numVertices++;\par
153                     printf({\cf22 "A antena foi adicionada.\\n"});\par
154                 \}\par
155                 {\cf19 else}\par
156                 \{\par
157                     printf({\cf22 "A antena n\'E3o foi adicionada.\\n"});\par
158                 \}\par
159             \}\par
160             {\cf19 break};\par
161 \par
162         {\cf19 case} 2: {\cf20 // Mostrar o grafo em formato de lista}\par
163             {\cf19 if} (graph == NULL)\par
164             \{\par
165                 printf({\cf22 "Erro: Grafo n\'E3o inicializado.\\n"});\par
166             \}\par
167             {\cf19 else}\par
168             \{\par
169                 result = ShowGraph(graph);\par
170                 {\cf19 if} (result == 0)\par
171                 \{\par
172                     printf({\cf22 "Nenhum v\'E9rtice foi mostrado (erro).\\n"});\par
173                 \}\par
174                 {\cf19 else}\par
175                 \{\par
176                     printf({\cf22 "Total de %d v\'E9rtices mostrados.\\n"}, result);\par
177                 \}\par
178             \}\par
179             {\cf19 break};\par
180 \par
181         {\cf19 case} 3: {\cf20 // Mostrar o grafo em formato de grid}\par
182             {\cf19 if} (graph == NULL)\par
183             \{\par
184                 printf({\cf22 "Erro: Grafo n\'E3o inicializado.\\n"});\par
185             \}\par
186             {\cf19 else}\par
187             \{\par
188                 result = ShowGraphAsGrid(graph);\par
189                 {\cf19 if} (result == 0)\par
190                 \{\par
191                     printf({\cf22 "Nenhum v\'E9rtice foi mostrado no grid (erro).\\n"});\par
192                 \}\par
193                 {\cf19 else}\par
194                 \{\par
195                     printf({\cf22 "Grid mostrado com %d v\'E9rtices.\\n"}, result);\par
196                 \}\par
197             \}\par
198             {\cf19 break};\par
199 \par
200         {\cf19 case} 4: {\cf20 // Carregar grafo de um ficheiro}\par
201             printf({\cf22 "Nome do ficheiro e formato: "});\par
202             scanf({\cf22 "%s"}, fileName);\par
203             {\cf19 if} (LoadGraph(fileName, graph))\par
204             \{\par
205                 printf({\cf22 "Grafo carregado com sucesso.\\n"});\par
206             \}\par
207             {\cf19 else}\par
208             \{\par
209                 printf({\cf22 "Grafo n\'E3o carregado.\\n"});\par
210             \}\par
211             {\cf19 break};\par
212 \par
213         {\cf19 case} 5: {\cf20 // DFT}\par
214             printf({\cf22 "Coordenada X: "});\par
215             scanf({\cf22 "%f"}, &x);\par
216             printf({\cf22 "Coordenada Y: "});\par
217             scanf({\cf22 "%f"}, &y);\par
218             DFT_FromCoordinates(x, y, graph);\par
219             {\cf19 break};\par
220 \par
221         {\cf19 case} 6: {\cf20 // BFT}\par
222             printf({\cf22 "Coordenada X: "});\par
223             scanf({\cf22 "%f"}, &x);\par
224             printf({\cf22 "Coordenada Y: "});\par
225             scanf({\cf22 "%f"}, &y);\par
226             BFT_FromCoordinates(x, y, graph);\par
227             {\cf19 break};\par
228 \par
229         {\cf19 case} 7: {\cf20 // Mostrar todos os caminhos entre duas antenas}\par
230             printf({\cf22 "Coordenada X da antena inicial: "});\par
231             scanf({\cf22 "%f"}, &x);\par
232             printf({\cf22 "Coordenada Y da antena inicial: "});\par
233             scanf({\cf22 "%f"}, &y);\par
234             {\cf18 float} startX = x, startY = y;\par
235 \par
236             printf({\cf22 "Coordenada X da antena final: "});\par
237             scanf({\cf22 "%f"}, &x);\par
238             printf({\cf22 "Coordenada Y da antena final: "});\par
239             scanf({\cf22 "%f"}, &y);\par
240             FindAllPaths(graph, startX, startY, x, y);\par
241             {\cf19 break};\par
242 \par
243         {\cf19 case} 8: {\cf20 // Mostrar interse\'E7\'F5es entre duas frequ\'EAncias}\par
244         \{\par
245             {\cf18 char} freqA, freqB;\par
246             printf({\cf22 "Primeira frequ\'EAncia: "});\par
247             scanf({\cf22 " %c"}, &freqA);\par
248             printf({\cf22 "Segunda frequ\'EAncia: "});\par
249             scanf({\cf22 " %c"}, &freqB);\par
250             {\cf18 int} result = findIntersections(graph, freqA, freqB);\par
251             printf({\cf22 "Total de %d interse\'E7\'F5es encontradas.\\n"}, result);\par
252             {\cf19 break};\par
253         \}\par
254 \par
255         {\cf19 case} 0:\par
256             printf({\cf22 "A encerrar...\\n"});\par
257             {\cf19 break};\par
258 \par
259         {\cf19 default}:\par
260             printf({\cf22 "Escolha inv\'E1lida.\\n"});\par
261             {\cf19 break};\par
262         \}\par
263     \} {\cf19 while} (choice != 0);\par
264     FreeGraph(graph); {\cf20 // Liberta toda a mem\'F3ria alocada}\par
265     {\cf19 return} 1;\par
266 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia ao ficheiro C:/Users/carlo/Desktop/EDA-Project/README.md\par \pard\plain 
{\tc\tcl2 \v C:/Users/carlo/Desktop/EDA-Project/README.md}
{\xe \v C:/Users/carlo/Desktop/EDA-Project/README.md}
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \'CDndice\par 
\pard\plain 
{\tc \v \'CDndice}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
